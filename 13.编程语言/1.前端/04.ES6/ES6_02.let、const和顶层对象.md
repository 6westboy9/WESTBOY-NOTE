
>[!important] 在ES6之前，JS只有全局作用域和函数作用域。ES6引入了块级作用域，使用let和const关键字来声明变量。
# 1.块级作用域

## 1.特点

### 1.不存在变量提升

### 2.暂时性死区

### 3.不允许重复声明


## 2.为什么需要块级作用域？

**ES5只有全局作用域和函数作用域**，没有块级作用域，这带来很多不合理的场景。

* 第一种场景，内层变量可能会覆盖外层变量。
* 第二种场景，用来计数的循环变量泄露为全局变量。

## 3.**IIFE不再必要**

>**块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名IIFE）不再必要了。**

```js
// IIFE写法
(function () {
    var tmp = ...;
    ...
}());

// 块级作用域写法
{
    let tmp = ...;
    ...
}
```
## 4.**块级作用域与函数声明**

函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。

```js
// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}
```

上面两种函数声明，根据ES5的规定都是非法的。但是，实际都能运行，不会报错。

>**ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。**

>**ES6引入了块级作用域，明确允许在块级作用域之中声明函数**。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

```js
function f() {
    console.log('I am outside!');
}

(function () {
    if (false) {
        // 重复声明一次函数f
        function f() {
            console.log('I am inside!');
        }
    }
    f();
}());
```

上面代码在ES5中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。

```js
// ES5环境
function f() {
    console.log('I am outside!');
}

(function () {
    function f() {
        console.log('I am inside!');
    }

    if (false) {
    }
    f();
}());
```

ES6就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在ES6浏览器中运行一下上面的代码，是会报错的，这是为什么呢？

```js
// 浏览器的ES6环境
function f() {
    console.log('I am outside!');
}

(function () {
    if (false) {
        // 重复声明一次函数f
        function f() {
            console.log('I am inside!');
        }
    }

    f();
}());
// Uncaught TypeError: f is not a function
```

原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在[附录B](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics)里面规定，浏览器的实现可以不遵守上面的规定，有自己的[行为方式](http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6)。

- 允许在块级作用域内声明函数。
- 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
- 同时，函数声明还会提升到所在的块级作用域的头部。

**注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。**

根据这三条规则，**浏览器的ES6环境中，块级作用域内声明的函数，行为类似于var声明的变量**。上面的例子实际运行的代码如下。

```js
// 浏览器的ES6环境
function f() {
    console.log('I am outside!');
}

(function () {
    var f = undefined;
    if (false) {
        function f() {
            console.log('I am inside!');
        }
    }

    f();
}());
// Uncaught TypeError: f is not a function
```


## 5.ES6之后六种声明变量方法

- `var`：用于函数作用域的变量声明
- `function`：用于函数声明
- `let`：用于**块级作用域的变量**声明 *ES6新增*
- `const`：用于**块级作用域的常量**声明 *ES6新增*
- `class`：用于**类**声明 *ES6新增*
- `import`：用于模块内导入绑定 *ES6新增*

# 2.顶层对象

## 1.顶层对象的属性与全局变量

**顶层对象**，在浏览器环境指的是window对象，在Node指的是global对象。<font color="#c0504d">ES5之中顶层对象的属性与全局变量是等价的</font>。

```js
window.a = 1;
a // 1

a = 2;
window.a // 2
```

上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。

> [!important] 顶层对象的属性与全局变量挂钩，被认为是JS语言最大的设计败笔之一
> - 一方面，这样的设计带来了几个很大的问题：
> 	- 首先，是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）
> 	- 其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）
> 	- 最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程
> - 另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的

ES6为了改变这一点，一方面规定，为了保持兼容性，var和function声明的全局变量，依旧是顶层对象的属性；另一方面规定，let、const、class声明的全局变量，不属于顶层对象的属性。也就是说，**从ES6开始全局变量将逐步与顶层对象的属性脱钩**。

```js
var a = 1;

// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined
```

上述a和b都是全局变量，但是a是顶层对象的属性，b不是~

## 2.globalThis

JS语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，**顶层对象在各种实现里面是不统一的**。

- 浏览器里面，顶层对象是window，但Node和Web Worker没有window。
- 浏览器和Web Worker里面，self也指向顶层对象，但是Node没有self。
- Node里面，顶层对象是global，但其他环境都不支持。

同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this关键字，但是有局限性。

- 全局环境中：this会返回顶层对象。但是，Node.js模块中this返回的是当前模块，ES6模块中this返回的是undefined。
- 函数里面：如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。
- 不管是严格模式，还是普通模式，`new Function('return this')()`，总是会返回全局对象。但是，如果浏览器用了<font color="#c0504d">CSP</font>，那么eval、new Function这些方法都可能无法使用。

>*CSP = Content Security Policy 内容安全策略*

综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。

[ES2020](https://github.com/tc39/proposal-global)在语言标准的层面，**引入globalThis作为顶层对象**。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。

```js
globalThis === window; // true
```



