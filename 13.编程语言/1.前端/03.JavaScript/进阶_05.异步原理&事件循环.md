* [异步原理和事件循环图文详解](https://blog.csdn.net/Victor2code/article/details/106985959)
* [JavaScript事件循环及异步原理（完全指北）](https://juejin.cn/post/6844903692752142343#heading-5)
* [JS异步编程六种方案](https://juejin.cn/post/6844903760280420366)



## 回调

回调函数则是一个被传递到另一个函数中的会在适当的时候被调用的函数。正如我们刚刚所看到的：回调函数曾经是 JavaScript 中实现异步函数的主要方式。

```js
function doStep1(init) {
  return init + 1;
}

function doStep2(init) {
  return init + 2;
}

function doStep3(init) {
  return init + 3;
}

function doOperation() {
  let result = 0;
  result = doStep1(result);
  result = doStep2(result);
  result = doStep3(result);
  console.log(`结果：${result}`);
}

doOperation();
```

现在我们有一个被分成三步的操作，每一步都依赖于上一步。在这个例子中，第一步给输入的数据加 1，第二步加 2，第三步加 3。从输入 0 开始，最终结果是 6（0+1+2+3）。作为同步代码，这很容易理解。但是如果我们用回调来实现这些步骤呢？

```js
function doStep1(init, callback) {
  const result = init + 1;
  callback(result);
}

function doStep2(init, callback) {
  const result = init + 2;
  callback(result);
}

function doStep3(init, callback) {
  const result = init + 3;
  callback(result);
}

function doOperation() {
  doStep1(0, (result1) => {
    doStep2(result1, (result2) => {
      doStep3(result2, (result3) => {
        console.log(`结果：${result3}`);
      });
    });
  });
}

doOperation();
```

因为必须在回调函数中调用回调函数，我们就得到了这个深度嵌套的 `doOperation()` 函数，这就更难阅读和调试了。在一些地方这被称为“回调地狱”或“厄运金字塔”（因为缩进看起来像一个金字塔的侧面）。

面对这样的嵌套回调，处理错误也会变得非常困难：你必须在“金字塔”的每一级处理错误，而不是在最高一级一次完成错误处理。




# 函数调用栈与任务队列

## 函数调用栈


## 任务队列

任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。

- <font color="#c0504d">宏任务</font>大概包括：
	- `script(整体代码)`
	- `setTimeout`
	- `setInterval`
	- `setImmediate（NodeJs）`
	- `I/O`操作
	- `UI rendering`
- <font color="#c0504d">微任务</font>大概包括：
	- `process.nextTick（NodeJs）`
	- `Promise`
	- `Object.observe(已废弃)`
	- `MutationObserver(html5新特性)`

来自不同任务源的任务会进入到不同的任务队列。其中`setTimeout`与`setInterval`是同源的。

>事件循环决定了代码的执行顺序，从全局上下文进入函数调用栈开始，直到调用栈清空，然后执行所有的微任务，当所有的微任务执行完毕之后，再执行宏任务，其中一个宏任务的任务队列执行完毕，再次执行所有的微任务，一直循环直至执行完毕。

```js
setTimeout(() => {
    console.log(4)
}, 0);

new Promise((resolve) => {
    console.log("promise start");
    for (var i = 0; i < 9; i++) {
        console.log("promise:" + i);
        i === 5 && resolve();
    }
    console.log("promise end");
}).then(() => {
    console.log(5);
});

console.log(3);
```

输出结果：

```
promise start
promise:0
promise:1
promise:2
promise:3
promise:4
promise:5
promise:6
promise:7
promise:8
promise end
3
5
4
```

