# 事件监听


## 1.HTML的on属性 → 不推荐

```html
<div onclick="console.log(2)">
  <button onclick="console.log(1)">点击</button>
</div>
```

上面代码中，`<button>`是`<div>`的子元素。`<button>`的`click`事件，也会触发`<div>`的`click`事件。由于on属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出1，再输出2，即事件从子元素开始冒泡到父元素。

直接设置on属性，与通过元素节点的`setAttribute`方法设置on属性，效果是一样的。

```js
el.setAttribute('onclick', 'doSomething()');
// 等同于
// <Element onclick="doSomething()">
```

## 2.元素节点的事件属性 → 不推荐

元素节点对象的事件属性，同样可以指定监听函数。

```js
// 示例1
window.onload = doSomething;

// 示例2
div.onclick = function (event) {
  console.log('触发事件');
};
```

使用这个方法指定的监听函数，也是只会在冒泡阶段触发。

## 3.EventTarget.addEventListener → 推荐

所有DOM节点实例都有`addEventListener`方法，用来为该节点定义事件的监听函数。

```js
window.addEventListener('load', doSomething, false);
```

## 4.小结

* 第一种HTML的on属性，违反了HTML与JavaScript代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。
* 第二种元素节点的事件属性的缺点在于，<font color="#f79646">同一个事件只能定义一个监听函数</font>，也就是说，如果定义两次`onclick`属性，后一次定义会覆盖前一次。因此，也不推荐使用。
* 第三种EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点：
	- <font color="#f79646">同一个事件可以添加多个监听函数</font>。
	- <font color="#f79646">能够指定在哪个阶段</font>（捕获阶段还是冒泡阶段）触发监听函数。
	- 除了DOM节点，其他对象（比如`window`、`XMLHttpRequest`等）也有这个接口，它<font color="#f79646">等于是整个JavaScript统一的监听函数接口</font>。

# 事件对象


# 事件类型

* 鼠标事件
* 键盘事件
* 进度事件
* 表单事件
* 触摸事件
* 资源事件
* 网页状态事件
* 窗口事件
* 剪贴板事件
* 焦点事件


# 事件传播

## 核心

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
      #box1 {
        width: 202px;
        height: 202px;
        border: 1px solid #000;
        padding: 50px;
      }

      #box2 {
        width: 100px;
        height: 100px;
        border: 1px solid #000;
        padding: 50px;
      }

      #box3 {
        width: 100px;
        height: 100px;
        border: 1px solid #000;
      }
    </style>
  </head>

  <body>
    <div id="box1">
      <div id="box2">
        <div id="box3"></div>
      </div>
    </div>
    <script>
      const oBox1 = document.getElementById('box1');
      const oBox2 = document.getElementById('box2');
      const oBox3 = document.getElementById('box3');

      oBox3.onclick = function () {
        console.log('我是box3的onclick');
      };

      oBox2.onclick = function () {
        console.log('我是box2的onclick');
      };

      oBox1.onclick = function () {
        console.log('我是box1的onclick');
      };
    </script>
  </body>
</html>
```


事件捕获和事件传播

![[Pasted image 20240809180517.png|525]]

![[Pasted image 20240809181858.png|400]]

一个事件发生后，会在子元素和父元素之间传播。这种传播分成三个阶段。

- **第一阶段**：从window对象传导到目标节点（上层传到底层），称为<font color="#f79646">捕获阶段</font>。
- **第二阶段**：在目标节点上触发，称为<font color="#f79646">目标阶段</font>。
- **第三阶段**：从目标节点传导回window对象（从底层传回上层），称为<font color="#f79646">冒泡阶段</font>。

这种三阶段的传播模型，使得同一个事件会在多个节点上触发。

<font color="#f79646">onxxx写法只能监听冒泡阶段</font>



## 阻止冒泡

修改上述案例中的单击事件

```js
oBox3.addEventListener('click', function (event) {
	console.log('我是box3的onclick');
	event.stopPropagation(); // 阻止事件传播
});

oBox2.addEventListener('click', function (event) {
	console.log('我是box2的onclick');
});

oBox1.addEventListener('click', function (event) {
	console.log('我是box1的onclick');
});
```

点击oBox3控制台输出（不会冒泡）
* 我是box3的onclick

点击oBox2控制台输出（仍然会冒泡）
* 我是box2的onclick
* 我是box1的onclick

## 阻止事件默认动作


## 事件委托





