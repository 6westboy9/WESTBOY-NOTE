# 1.Error实例对象

JavaScript语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。大多数JavaScript引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。

* message：错误提示信息
* name：错误名称（非标准属性）
* stack：错误的堆栈（非标准属性）

```js
function throwIt() {
    throw new Error('自定义错误');
}

function catchIt() {
    try {
        throwIt();
    } catch(e) {
        console.log(e.stack); // print stack trace
    }
}
```

```
catchIt()
VM2410:9 Error: 自定义错误
    at throwIt (<anonymous>:2:11)
    at catchIt (<anonymous>:7:9)
    at <anonymous>:1:1
```

上面代码中，错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。

# 2.原生错误类型

Error实例对象是最一般的错误类型，在它的基础上，JavaScript还定义了其他6种错误对象。也就是说，<font color="#f79646">存在Error的6个派生对象</font>。


## 2.1.SyntaxError

SyntaxError对象是<font color="#f79646">解析代码时</font>发生的语法错误。

```js
// 变量名错误
var 1a;
// Uncaught SyntaxError: Invalid or unexpected token

// 缺少括号
console.log 'hello');
// Uncaught SyntaxError: Unexpected string
```

## 2.2.ReferenceError

SyntaxError对象是解析代码时发生的语法错误。

>场景1.引用一个不存在的变量时

```js
// 使用一个不存在的变量
unknownVariable
// Uncaught ReferenceError: unknownVariable is not defined
```

>场景2.将一个值分配给无法分配的对象

比如对函数的运行结果赋值

```js
// 等号左侧不是变量
console.log() = 1
// Uncaught ReferenceError: Invalid left-hand side in assignment
```

## 2.3.RangeError

RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况：

* 一是数组长度为负数。
* 二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。

```js
// 数组长度不得为负数
new Array(-1)
// Uncaught RangeError: Invalid array length
```

## 2.4.TypeError

TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。

```js
new 123
// Uncaught TypeError: 123 is not a constructor

var obj = {};
obj.unknownMethod()
// Uncaught TypeError: obj.unknownMethod is not a function
```
## 2.5.URIError

URIError对象是URI相关函数的参数不正确时抛出的错误，主要涉及函数：

* encodeURI()
* decodeURI()
* encodeURIComponent()
* decodeURIComponent()
* escape()
* unescape()

```js
```

## 2.6.EvalError → 废弃

eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。

## 2.7.小结

以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息。

```js
var err1 = new Error('出错了！');
var err2 = new RangeError('出错了，变量超出有效范围！');
var err3 = new TypeError('出错了，变量类型无效！');

err1.message // "出错了！"
err2.message // "出错了，变量超出有效范围！"
err3.message // "出错了，变量类型无效！"
```

# 3.自定义错误

除了JavaScript原生提供的<font color="#f79646">七</font>种错误对象，还可以定义自己的错误对象。

```js
function UserError(message) {
  this.message = message || '默认信息';
  this.name = 'UserError';
}

UserError.prototype = new Error();
UserError.prototype.constructor = UserError;
```

上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了

```js
new UserError('这是自定义的错误！');
```

# 4.throw语句

throw语句的作用是手动中断程序执行，抛出一个错误。

```js
var x = -1;

if (x <= 0) {
  throw new Error('x 必须为正数');
}
```

throw也可以抛出自定义错误。

```js
function UserError(message) {
  this.message = message || '默认信息';
  this.name = 'UserError';
}

throw new UserError('出错了！');
```

实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。

```js
// 抛出一个字符串
throw 'Error！';
// Uncaught Error！

// 抛出一个数值
throw 42;
// Uncaught 42

// 抛出一个布尔值
throw true;
// Uncaught true

// 抛出一个对象
throw {
  toString: function () {
    return 'Error!';
  }
};
// Uncaught {toString: ƒ}
```

对于 JavaScript引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。

# 5.try-catch结构

一旦发生错误，程序就中止执行了。JavaScript提供了try...catch结构，允许对错误进行处理，选择是否往下执行。

```js
try {
  throw new Error('出错了!');
} catch (e) {
  console.log(e.name + ": " + e.message);
  console.log(e.stack);
}
```

# 6.finally代码块

try...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。

```js
function cleansUp() {
  try {
    throw new Error('出错了……');
    console.log('此行不会执行');
  } finally {
    console.log('完成清理工作');
  }
}
```

上面代码中，由于没有catch语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行finally代码块，然后再向用户提示报错信息。

```js
function idle(x) {
  try {
    console.log(x);
    return 'result';
  } finally {
    console.log('FINALLY');
  }
}

idle('hello')
// hello
// FINALLY
```

上面代码中，try代码块没有发生错误，而且里面还包括return语句，但是finally代码块依然会执行。而且，这个函数的返回值还是result。

>下面是finally代码块用法的典型场景

```js
openFile();

try {
  writeFile(Data);
} catch(e) {
  handleError(e);
} finally {
  closeFile();
}
```

>下面的例子充分反映了try...catch...finally这三者之间的执行顺序

```js
function f() {
  try {
    console.log(0);
    throw 'bug';
  } catch(e) {
    console.log(1);
    return true; // 这句原本会延迟到 finally 代码块结束再执行
    console.log(2); // 不会运行
  } finally {
    console.log(3);
    return false; // 这句会覆盖掉前面那句 return
    console.log(4); // 不会运行
  }

  console.log(5); // 不会运行
}

var result = f();
// 0
// 1
// 3

result
// false
```

>常见面试场景

下面的例子，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。

```js
function f() {
  try {
    throw '出错了！';
  } catch(e) {
    console.log('捕捉到内部错误');
    throw e; // 这句原本会等到finally结束再执行
  } finally {
    return false; // 直接返回
  }
}

try {
  f();
} catch(e) {
  // 此处不会执行
  console.log('caught outer "bogus"');
}
```



