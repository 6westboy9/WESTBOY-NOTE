# 创建函数

## 1.函数声明

一个函数定义（也称为函数声明，或函数语句）由`function`关键字，并跟随以下部分组成：

* 函数名称。
* 函数参数列表，包围在括号中并由逗号分隔。
* 定义函数的语句，用大括号括起来。

```js
function square(number) {  
    return number * number;  
}
```

ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用return语句来返回函数的值，用法是后跟要返回的值。

## 2.函数表达式

适用函数表达式创建函数时，可以是<font color="#c0504d">匿名</font>的，它不必有一个名称。

```js
const square = function (number) {  
    return number * number;  
};  
  
console.log(square(4)); // 16
```

然而，<font color="#c0504d">也可以为函数表达式提供名称</font>，并且可以用于在函数内部代指其本身，或者在调试器堆栈跟踪中识别该函数：

```js
const factorial = function fac(n) {
    return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

<font color="#c0504d">进阶</font>

```js
const factorial = function (n) {
	return n < 2 ? 1 : n * arguments.callee(n - 1);
};

console.log(factorial(3)); // 6
```

## 3.箭头函数

ECMAScript 6新增了使用胖箭头语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。<font color="#c0504d">任何可以使用函数表达式的地方，都可以使用箭头函数</font>。

```js
let arrowSum = (a, b) => {
    return a + b;
};

let functionExpressionSum = function (a, b) {
    return a + b;
};

console.log(arrowSum(5, 8)); // 13
console.log(functionExpressionSum(5, 8)); // 13
```

箭头函数简洁的语法非常适合嵌入函数的场景：

```js
// [2, 3, 4]
console.log(ints.map(function (i) {
    return i + 1;
}));

// [2, 3, 4]
console.log(ints.map((i) => {
    return i + 1
})); 
```

如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号：

```js
// 以下两种写法都有效
let double = (x) => {
    return 2 * x;
};

let triple = x => {
    return 3 * x;
};

// 没有参数需要括号
let getRandom = () => {
    return Math.random();
};

// 多个参数需要括号
let sum = (a, b) => {
    return a + b;
};

// 无效的写法：
// let multiply = a, b => { return a * b; };
```

> [!danger] 局限性
> 箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用arguments、super和new.target，也不能用作构造函数。此外，箭头函数也没有prototype属性。

## 4.Function构造函数

在运行时用[`Function`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function)构造函数从一个字符串创建一个函数，很像[`eval()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval)函数。

由`Function`构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被`Function`构造函数创建时所在的作用域的变量。这一点与使用[`eval()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval)执行创建函数的代码不同。

```js
var x = 10;

function createFunction1() {
    const x = 20;
    return new Function("return x;"); // 这个x指的是全局x
}

function createFunction2() {
    const x = 20;

    function f() {
        return x; // 这个x指的是上面的局部x
    }

    return f;
}

const f1 = createFunction1();
console.log(f1()); // 10
const f2 = createFunction2();
console.log(f2()); // 20
```

虽然这段代码可以在浏览器中正常运行，但在`Node.js`中`f1()`会产生一个<font color="#c0504d">找不到变量x的ReferenceError</font>。这是因为<font color="#c0504d">在Node中顶级作用域不是全局作用域</font>，而x其实是在当前模块的作用域之中。

> [!note] 网上说法
> 通过函数表达式定义的函数和通过函数声明定义的函数只会被解析一次，而Function构造函数定义的函数却不同。每次构造函数被调用，传递给Function构造函数的函数体字符串都要被解析一次 。 所以Function构造函数应尽可能地避免使用。

```js
let sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
console.log(sum instanceof Function); // true
console.log(sum(1, 2)); // 3
```

> [!note] 红宝书中的说法
> 我们不推荐使用这种语法来定义函数，因为这段代码会被解释两次：第一次是将它当作常规ECMAScript代码，第二次是解释传给构造函数的字符串。这显然会影响性能。不过，把函数想象为对象，把函数名想象为指针是很重要的。而上面这种语法很好地诠释了这些概念。


# 函数名

* 因为<font color="#c0504d">函数名就是指向函数的指针</font>，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称。
* ECMAScript 6的所有函数对象都会暴露一个只读的name属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。
* 即使函数没有名称，也会如实显示成空字符串。如果它是使用Function构造函数创建的，则会标识成`anonymous`。

```js
function foo() {}
let bar = function() {};
let baz = () => {};
console.log(foo.name);                   // foo
console.log(bar.name);                   // bar
console.log(baz.name);                   // baz
console.log((() => {}).name);            //（空字符串）
console.log((new Function()).name);      // anonymous
```

# 函数参数

>① <font color="#c0504d">ECMAScript函数既不关心传入的参数个数，也不关心这些参数的数据类型</font>。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。主要因为ECMAScript函数的<font color="#c0504d">参数在内部表现为一个数组</font>。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。

>② 在使用`function`关键字定义（<font color="#c0504d">非箭头</font>）函数时，可以在函数内部访问`arguments`对象，从中取得传进来的每个参数值。`arguments`对象是一个伪数组对象（也叫类数组对象，<font color="#c0504d">不是Array的实例</font>），因此可以使用中括号语法访问其中的元素（第一个参数是`arguments[0]`，第二个参数是`arguments[1]`）。而要确定传进来多少个参数，可以访问`arguments.length`属性。

[了解伪数组](https://juejin.cn/post/6966525287110541348)

```js
function sayHi(name, message) {
    console.log("Hello " + name + ", " + message);
}

// 与其他语言不同，在ECMAScript中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名参数的机制~
function sayHi2() {
    console.log("Hello " + arguments[0] + ", " + arguments[1]);
}

sayHi('xw', 'haha'); // Hello xw, haha
sayHi2('xw', 'haha'); // Hello xw, haha
```

```js
function howManyArgs() {
    console.log(arguments.length);
}
howManyArgs("string", 45); // 2
howManyArgs();             // 0
howManyArgs(12);           // 1
```

>③ 重载

```js
function doAdd() {
    if (arguments.length === 1) {
        console.log(arguments[0] + 10);
    } else if (arguments.length === 2) {
        console.log(arguments[0] + arguments[1]);
    }
}

doAdd(10);       // 20
doAdd(30, 20);   // 50
```

虽然不像真正的函数重载那么明确，但这已经足以弥补ECMAScript在这方面的缺失了。

>④ `arguments`对象可以跟命名参数一起使用

```js
function doAdd(num1, num2) {
    if (arguments.length === 1) {
        console.log(num1 + 10);
    } else if (arguments.length === 2) {
        console.log(arguments[0] + num2);
    }
}

doAdd(10); // 20
doAdd(10, 20); // 30
```

在这个`doAdd()`函数中，同时使用了两个命名参数和`arguments`对象。命名参数`num1`保存着与`arugments[0]`一样的值，因此使用谁都无所谓。（同样，`num2`也保存着跟`arguments[1]`一样的值。）

>⑤ `arguments`对象中的值始终会与对应的命名参数同步

```js
function doAdd(num1, num2) {
    arguments[1] = 10;
    console.log(arguments[0] + num2); // num2=arguments[1]=10
}

doAdd(1, 2); // 11
doAdd(1); // NAN → num2=undefined，undefined+1结果NaN
var a;
console.log(a); 
console.log(a + 1);
```

这个`doAdd()`函数把第二个参数的值重写为10。因为`arguments`对象的值会自动同步到对应的命名参数，所以修改`arguments[1]`也会修改`num2`的值，因此两者的值都是10。<font color="#c0504d">但这并不意味着它们都访问同一个内存地址</font>，它们在内存中还是分开的，只不过会保持同步而已。

另外如果只传了一个参数，然后把`arguments[1]`设置为某个值，那么这个值并不会反映到第二个命名参数。这是因为`arguments`对象的长度是<font color="#c0504d">根据传入的参数个数确定的</font>，而非定义函数时给出的命名参数个数确定的。

对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是`undefined`。这就类似于定义了变量而没有初始化。比如，如果只给`doAdd()`传了一个参数，那么`num2`的值就是`undefined`。

>⑥ 严格模式下的不同

* `arguments`会有一些变化。首先，像前面那样给`arguments[1]`赋值不会再影响`num2`的值。就算把`arguments[1]`设置为10，`num2`的值仍然还是传入的值。
* 其次，在函数中尝试重写`arguments`对象会导致语法错误，代码也不会执行。

>⑦ 箭头函数中的参数

如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用`arguments`关键字访问，而只能通过定义的命名参数访问。

```js
function foo() {
    console.log(arguments[0]);
}

foo(5); // 5
let bar = () => {
    console.log(arguments[0]);
};
bar(5);   // ReferenceError: arguments is not defined
```

虽然箭头函数中没有`arguments`对象，但可以在包装函数中把它提供给箭头函数：

```js
function foo() {
    let bar = () => {
        console.log(arguments[0]); // 5
    };
    bar();
}

foo(5); // 5
```

# 没有重载

如果在ECMAScript中定义了两个同名函数，则后定义的会覆盖先定义的。

# 默认参数

ECMAScript5.1及以前

```js
function makeKing(name) {
	name = (typeof name !== 'undefined') ? name : 'Henry';
	return `King ${name} VIII`;
}

console.log(makeKing());           // 'King Henry VIII'
console.log(makeKing('Louis'));    // 'King Louis VIII'
```

ECMAScript 6之后

```js
function makeKing(name = 'Henry') {
	return `King ${name} VIII`;
}

console.log(makeKing('Louis'));    // 'King Louis VIII'
console.log(makeKing());           // 'King Henry VIII'
```

给参数传`undefined`相当于没有传值

```js
function makeKing(name = 'Henry', numerals = 'VIII') {
	return `King ${name} ${numerals}`;
}

console.log(makeKing());                     // 'King Henry VIII'
console.log(makeKing('Louis'));              // 'King Louis VIII'
console.log(makeKing(undefined, 'VI'));      // 'King Henry VI'
```

在使用默认参数时，`arguments`对象的值不反映参数的默认值，只反映传给函数的参数。



# 调用函数



## 1.直接调用


## 2.通过对象调用


## 3.new调用


## 4.call或apply


# 拓展

## 1.回调函数


## 2.匿名函数


## 3.箭头函数


## 4.IIFE_立即调用函数表达式


IIFE是一种在JavaScript中创建私有作用域的常用方法，通常用于避免变量污染全局作用域。例如：

```js
(function() {
  var a = 10;
  console.log(a); // 10
})();
```

在ES6之前，JavaScript只有全局作用域和函数作用域，没有块级作用域（例如在`if`或`for`语句中的作用域）。这使得在函数内声明的变量在整个函数中都是可见的：

```js
function example() {
  if (true) {
    var x = 5;
  }
  console.log(x); // 5
}
```

ES6引入了`let`和`const`，这两个关键字创建了块级作用域：

```js
function example() {
  if (true) {
    let x = 5;
    console.log(x); // 5
  }
  console.log(x); // ReferenceError: x is not defined
}
```

在这个例子中，`let`声明的变量`x`只在`if`语句的块级作用域中可见，离开这个块之后，`x`就不存在了。

> [!important] 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名IIFE）不再必要了

>为什么块级作用域减少了对IIFE的需求？

在有了块级作用域之后，我们可以更简单地创建一个局部作用域，而不需要使用IIFE。例如：

```js
{
  let a = 10;
  console.log(a); // 10
}
console.log(a); // ReferenceError: a is not defined
```

由于块级作用域的出现，我们在很多情况下可以用更简单的方法来创建局部作用域，而不再需要使用匿名立即执行函数表达式。

## 5.构造函数

# 原型链

* https://juejin.cn/post/6844903989088092174
* https://juejin.cn/post/6984678359275929637


- JS中分为函数对象和普通对象，每个对象都有`__proto__`属性，但是<font color="#c0504d">只有函数对象</font>才有`prototype`属性
- Object、Function都是JS内置的函数，类似的还有我们常用到的Array、RegExp、Date、Boolean、Number、String
- 属性`__proto__`是一个对象，它有两个属性，`constructor`和`__proto__`
- 原型对象（如下`Person.prototype`就称之为原型对象）有一个默认的`constructor`属性，用于记录实例是由哪个构造函数创建

```js
// 有以下构造函数Person，他的原型上有所属国属性motherland='China'
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.motherland = 'China'

// 通过new Person()创建的person01实例
let person01 = new Person('小明', 18);
```

```js
1.Person.prototype.constructor == Person // 准则1：原型对象（即Person.prototype）的constructor指向构造函数本身
2.person01.__proto__ == Person.prototype // 准则2：实例（即person01）的__proto__和原型对象指向同一个地方
```




# 作用域


# 闭包


