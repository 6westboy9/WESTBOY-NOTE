# 1.概述

Promise对象是JS的异步操作解决方案，为异步操作提供统一接口。它起到代理作用，充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。

```js
// 传统写法
step1(function (value1) {
  step2(value1, function(value2) {
    step3(value2, function(value3) {
      step4(value3, function(value4) {
        // ...
      });
    });
  });
});

// Promise 的写法
(new Promise(step1))
  .then(step2)
  .then(step3)
  .then(step4);
```

Promise原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ES6将其写入语言标准，目前JavaScript原生支持Promise对象。

# 2.Promise对象的状态

Promise对象通过自身的状态，来控制异步操作。Promise实例具有三种状态。

* 异步操作未完成：<font color="#c0504d">pending</font>
* 异步操作成功：<font color="#c0504d">fulfilled</font>
* 异步操作失败：<font color="#c0504d">rejected</font>

上面三种状态里面，fulfilled和rejected合在一起称为<font color="#c0504d">resolved</font>，已定型。

这三种的状态的变化途径只有两种。

* 从“未完成”到“成功”
* 从“未完成”到“失败”

一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是Promise这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise实例的状态变化只可能发生一次。

因此，Promise的最终结果只有两种。

* 异步操作成功，Promise实例传回一个值，状态变为fulfilled。
* 异步操作失败，Promise实例抛出一个错误，状态变为rejected。

# 3.Promise的构造函数

JS提供原生的Promise构造函数，用来生成Promise实例。

```js
var promise = new Promise(function (resolve, reject) {
  // ...
  if (/* 异步操作成功 */){
    resolve(value);
  } else { /* 异步操作失败 */
    reject(new Error());
  }
});
```

上面代码中，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JS引擎提供，不用自己实现。

* resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。
* reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

下面是一个例子。

```js
function timeout(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms, 'done');
  });
}

timeout(100)
```

上面代码中，timeout(100)返回一个Promise实例。100毫秒以后，该实例的状态会变为fulfilled。

# 4.Promise.prototype.then

Promise实例的then方法，用来添加回调函数。

then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。

```js
var p1 = new Promise(function (resolve, reject) {
  resolve('成功');
});
p1.then(console.log, console.error);
// "成功"

var p2 = new Promise(function (resolve, reject) {
  reject(new Error('失败'));
});
p2.then(console.log, console.error);
// Error: 失败
```

上面代码中，p1和p2都是Promise实例，它们的then方法绑定两个回调函数：成功时的回调函数console.log，<font color="#c0504d">失败时的回调函数console.error（可以省略）</font>。p1的状态变为成功，p2的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。

then方法可以链式使用。

```js
p1.then(step1)
  .then(step2)
  .then(step3)
  .then(console.log, console.error);
```

上面代码中，p1后面有四个then，意味依次有四个回调函数。只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。

最后一个then方法，回调函数是console.log和console.error，用法上有一点重要的区别。<font color="#c0504d">console.log只显示step3的返回值，而console.error可以显示p1、step1、step2、step3之中任意一个发生的错误</font>。举例来说，如果step1的状态变为rejected，那么step2和step3都不会执行了（因为它们是resolved的回调函数）。Promise开始寻找，接下来第一个为rejected的回调函数，在上面代码中是console.error。

这就是说，**Promise对象的报错具有传递性**。

# 5.then用法辨析

Promise的用法，简单说就是一句话：使用then方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？


# 6.案例.图片加载

下面是使用Promise完成图片的加载。

```js
var preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    var image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
```

上面代码中，image是一个图片对象的实例。它有两个事件监听属性，onload属性在图片加载成功后调用，onerror属性在加载失败调用。

上面的preloadImage函数用法如下。

```js
preloadImage('https://example.com/my.jpg')
  .then(function (e) { document.body.append(e.target) })
  .then(function () { console.log('加载成功') })
```

上面代码中，图片加载成功以后，onload属性会返回一个事件对象，因此第一个then方法的回调函数，会接收到这个事件对象。该对象的target属性就是图片加载后生成的DOM节点。

# 7.微任务

Promise的回调函数属于异步任务，会在同步任务之后执行。

```js
new Promise(function (resolve, reject) {
  resolve(1);
}).then(console.log);

console.log(2);
// 2
// 1
```


但是，Promise的回调函数不是正常的异步任务，而是**微任务**，microtask。它们的区别在于，**正常任务追加到下一轮事件循环，微任务追加到本轮事件循环**。这意味着，**微任务的执行时间一定早于正常任务**。

```js
setTimeout(function() {
  console.log(1);
}, 0);

new Promise(function (resolve, reject) {
  resolve(2);
}).then(console.log);

console.log(3);
// 3
// 2
// 1
```

上面代码的输出结果是321。这说明then的回调函数的执行时间，早于setTimeout(fn,0)。因为then是本轮事件循环执行，setTimeout(fn,0)在下一轮事件循环开始时执行。


# 8.resolve传参

1. 普通的值或者对象
2. 传入一个Promise对象，那么当前的Promise的状态由传参Promise对象来决定
3. 传入一个对象，并且这个对象有实现then方法，那么也会执行该then方法，并且由该then方法决定后续状态


