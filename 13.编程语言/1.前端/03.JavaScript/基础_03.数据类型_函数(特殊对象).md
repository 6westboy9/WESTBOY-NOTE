# 1.基础

## 1.1.函数的声明


### 1.1.1.function命令


### 1.1.2.函数表达式


### 1.1.3.Function构造函数


## 1.2.函数的重复声明


## 1.3.第一等公民


## 1.4.函数名的提升


# 2.函数的属性和方法


## 2.1.属性-name


## 2.2.属性-length


## 2.3.方法-toString


# 3.函数的作用域


## 3.1.定义

作用域指的是变量存在的范围。<span style="background:#fff88f">在ES5的规范中，JavaScript只有两种作用域</span>：

* 一种是**全局作用域**，变量在整个程序中一直存在，所有地方都可以读取；
* 另一种是**函数作用域**，变量只在函数内部存在。

>ES6 又新增了**块级作用域**，本教程不涉及。

## 3.2.函数内部的变量提升

与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。

```js
function foo(x) {
  if (x > 100) {
    var tmp = x - 100;
  }
}

// 等同于
function foo(x) {
  var tmp;
  if (x > 100) {
    tmp = x - 100;
  };
}
```

## 3.2.函数本身的作用域

```js
var a = 1;
var x = function () {
  console.log(a);
};

function f() {
  var a = 2;
  x();
}
```

上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。

<span style="background:#fff88f">总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</span>

```js
var x = function () {
  console.log(a);
};

function y(f) {
  var a = 2;
  f();
}

y(x)
// ReferenceError: a is not defined
```

上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。

<span style="background:#fff88f">同样的，函数体内部声明的函数，作用域绑定函数体内部。</span>

```js
function foo() {
  var x = 1;
  function bar() {
    console.log(x);
  }
  return bar;
}

var x = 2;
var f = foo();
f() // 1
```

上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。<font color="#c0504d">正是这种机制，构成了下文要讲解的“闭包”现象</font>。→ [[基础_03.数据类型_函数(特殊对象)#5.1.闭包]]

# 4.参数

## 4.1.参数的省略


## 4.2.传递方式


## 4.3.同名参数


## 4.4.arguments对象


# 5.其他知识点


## 5.1.闭包

### 闭包

```js
function fn1() {
	var num = 10;
	function fn2() {
		debugger
		console.log(num);
	}
	fn2();
}
fn1(); // 输出结果10
```

**被访问的变量所在的函数就是一个闭包函数**，闭包函数就是fn1，fn2的作用域当中访问到了fn1函数中的n这个局部变量 ，所以此时fn1就是一个闭包函数。

我们可以用Chrome的调试工具验证一下。

![[Pasted image 20241216113426.png|1200]]

fn2的作用域当中访问到了fn1函数中的num这个局部变量，所以此时fn1就是一个闭包函数（被访问的变量所在的函数就是一个闭包函数）

也有人说，闭包是一种现象，一个作用域访问了另外一个函数中的局部变量，如果有这种现象的产生，就有了闭包的发生。我觉的这样理解也是没有什么问题的。

### 内存泄露

```js
var fn  =function(){
	var sum = 0
	return function(){
		sum++
		console.log(sum);
	}
}
fn()() //1
fn()() //1
```

这里出现了一个小问题，sum为什么没有自增？如果想要实现自增怎么操作？回答这个问题需要先了解一下JS中内存回收机制。

我这里直接简单解释一下，执行`fn()()`后，`fn()()`已经执行完毕，没有其他资源在引用fn，此时内存回收机制会认为fn不需要了，就会在内存中释放它。

那如何不被回收呢？

```js
var fn  =function(){
	var sum = 0
	return function(){
		sum++
		console.log(sum);
	}
}
fn1=fn() 
fn1()   //1
fn1()   //2
fn1()   //3
```

这种情况下，fn1一直在引用`fn()`，此时内存就不会被释放，就能实现值的累加。那么问题又来了，这样的函数如果太多，就会造成**内存泄漏**。

内存泄漏了怎么办呢？我们可以手动释放一下。

```js
var fn  =function(){
	var sum = 0
	return function(){
		sum++
		console.log(sum);
	}
}

fn1=fn() 
fn1()   //1
fn1()   //2
fn1()   //3

fn1 = null // fn1的引用fn被手动释放了
fn1=fn()   // num再次归零
fn1()      // 1
```

### 闭包的作用

>1.数据隐藏和封装

可以将一些数据隐藏在函数内部，通过闭包提供的函数来访问和操作这些数据，而外部无法直接访问这些数据，提高了代码的安全性和可维护性。

```js
function createCounter() {
 let count = 0;
 return {
   increment: function() {
	 count++;
   },
   getCount: function() {
	 return count;
   }
 };
}
const counter = createCounter();
counter.increment();
console.log(counter.getCount()); // 1
```

>2.模拟私有变量

在JS中没有真正的私有变量，但可以使用闭包来模拟。外部无法直接访问内部的变量，只能通过特定的方法来操作。

```js
function createPerson() {
 let name = "John";
 return {
   getName: function() {
	 return name;
   },
   setName: function(newName) {
	 name = newName;
   }
 };
}
const person = createPerson();
console.log(person.getName()); // John
person.setName("Jane");
console.log(person.getName()); // Jane
```

>3.记忆函数

闭包可以让函数记住之前的状态，例如在记忆函数中，函数可以记住之前的计算结果，避免重复计算。

```js
function memoize(func) {
 let cache = {};
 return function(...args) {
   // 使用参数作为缓存的key
   let key = JSON.stringify(args);
   if (cache[key]) {
	 return cache[key];
   } else {
	 let result = func(...args);
	 cache[key] = result;
	 return result;
   }
 };
}
const expensiveFunction = (x) => {
 console.log('Calculating...');
 return x * 2;
};
const memoizedFunction = memoize(expensiveFunction);
console.log(memoizedFunction(5)); // Calculating... then returns 10
console.log(memoizedFunction(5)); // Returns 10 directly without recalculating
```



## 5.2.立即调用的函数表达式-IIFE


# 6.eval命令


 





