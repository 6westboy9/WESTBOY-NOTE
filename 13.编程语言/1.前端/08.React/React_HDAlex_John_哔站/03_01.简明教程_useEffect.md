# React 简明教程 - useEffect

本节通过一个**随机建议生成器**应用，学习 React 中最重要的 Hook 之一：`useEffect`。

## 项目说明

```
lecture-08/final/
├── src/
│   ├── App.jsx       # 主组件（使用 useEffect）
│   └── App.css       # 样式文件
└── package.json      # Vite + React 项目配置
```

> **注意**：本示例使用 Vite + React 开发环境，需要 Node.js 支持。

---

## 1. 完整代码 (App.jsx)

```jsx
import { useEffect, useState } from "react";

function App() {
  const [advice, setAdvice] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  async function getAdvice() {
    setIsLoading(true);

    const response = await fetch("https://api.adviceslip.com/advice");
    const data = await response.json();

    setIsLoading(false);
    setAdvice(data.slip.advice);
  }

  // ⏺ useEffect - 在组件挂载时执行副作用
  useEffect(() => {
    getAdvice();
  }, []);

  return (
    <>
      <h1>Advice</h1>
      <div>{isLoading ? "Loading..." : advice}</div>
      <button onClick={getAdvice}>Get Advice</button>
    </>
  );
}

export default App;
```

---

## 2. 什么是副作用？

**副作用（Side Effect）**是指函数对外部环境产生影响的操作。

| 操作类型 | 示例 |
|---|---|
| **数据获取** | `fetch()`、`axios` 请求 API |
| **定时器** | `setTimeout`、`setInterval` |
| **手动 DOM 操作** | `document.querySelector()`、直接修改 DOM |
| **订阅事件** | `addEventListener`、WebSocket 连接 |
| **写入 localStorage** | `localStorage.setItem()` |

```javascript
// 副作用示例
useEffect(() => {
  // 数据获取（副作用）
  fetch("/api/data").then(res => res.json());

  // 定时器（副作用）
  const timer = setTimeout(() => {}, 1000);

  // 订阅事件（副作用）
  window.addEventListener("resize", handleResize);

  // 清理函数
  return () => {
    clearTimeout(timer);
    window.removeEventListener("resize", handleResize);
  };
}, []);
```

---

## 3. useEffect 语法

```javascript
useEffect(setup, dependencies?)
```

| 参数 | 类型 | 说明 |
|---|---|---|
| `setup` | `() => (cleanup \| undefined)` | 副作用函数，可选返回清理函数 |
| `dependencies` | `Array<any>` | 依赖数组，可选 |

### 3.1 基本用法

```javascript
// 用法 1：每次渲染后都执行（不推荐）
useEffect(() => {
  console.log("组件渲染了");
});

// 用法 2：仅在组件挂载时执行一次
useEffect(() => {
  console.log("组件挂载了");
}, []);

// 用法 3：依赖项变化时执行
useEffect(() => {
  console.log("count 变化了:", count);
}, [count]);

// 用法 4：带清理函数
useEffect(() => {
  const timer = setTimeout(() => {}, 1000);
  return () => clearTimeout(timer);  // 清理
}, []);
```

---

## 4. 依赖数组详解

### 4.1 不同依赖数组的行为

```javascript
// ❌ 每次渲染后都执行（容易造成无限循环）
useEffect(() => {
  fetchData();
});

// ✅ 仅在组件挂载时执行一次
useEffect(() => {
  fetchData();
}, []);

// ✅ count 变化时执行
useEffect(() => {
  console.log("count:", count);
}, [count]);

// ✅ 多个依赖
useEffect(() => {
  fetchData(user_id, page);
}, [user_id, page]);
```

### 4.2 依赖数组规则图示

```
┌─────────────────────────────────────────────────────────┐
│                 useEffect 执行时机                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  无依赖数组：                                            │
│  useEffect(() => {})                                    │
│  ─────────────────────────────────────                  │
│  渲染 → 执行 → 渲染 → 执行 → 渲染 → 执行...             │
│                                                         │
│  空依赖数组 []：                                          │
│  useEffect(() => {}, [])                                │
│  ─────────────────────────────────────                  │
│  挂载 → 执行 ─────────────────────────────               │
│                                                         │
│  有依赖 [count]：                                         │
│  useEffect(() => {}, [count])                           │
│  ─────────────────────────────────────                  │
│  挂载 → 执行                                             │
│  count变化 → 执行                                         │
│  count变化 → 执行                                         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 5. 本例代码详解

### 5.1 状态定义

```javascript
const [advice, setAdvice] = useState("");           // 存储建议内容
const [isLoading, setIsLoading] = useState(false); // 加载状态
```

### 5.2 异步获取数据

```javascript
async function getAdvice() {
  setIsLoading(true);  // 开始加载

  // 调用 API 获取随机建议
  const response = await fetch("https://api.adviceslip.com/advice");
  const data = await response.json();

  setIsLoading(false); // 加载完成
  setAdvice(data.slip.advice); // 更新建议内容
}
```

### 5.3 useEffect 的使用

```javascript
useEffect(() => {
  getAdvice();  // 组件挂载时自动获取建议
}, []);         // 空依赖数组 = 只执行一次
```

**执行时机**：

```
┌─────────────────────────────────────────────────────────┐
│                   组件生命周期                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 组件挂载                                              │
│     ↓                                                    │
│  2. useEffect 执行 → getAdvice()                         │
│     ↓                                                    │
│  3. 开始加载 (isLoading = true)                          │
│     ↓                                                    │
│  4. API 请求返回                                          │
│     ↓                                                    │
│  5. 更新状态 (advice, isLoading)                         │
│     ↓                                                    │
│  6. 重新渲染显示建议                                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 6. 条件渲染

```javascript
<div>
  {isLoading ? "Loading..." : advice}
</div>
```

| isLoading 值 | 显示内容 |
|---|---|
| `true` | 显示 "Loading..." |
| `false` | 显示获取的建议内容 |

---

## 7. useEffect 与异步操作

### 7.1 正确做法

```javascript
// ✅ 推荐：在 useEffect 中调用独立的异步函数
useEffect(() => {
  async function fetchData() {
    const data = await fetch("/api/data");
    setData(data);
  }
  fetchData();
}, []);

// ✅ 推荐：使用外部定义的异步函数
useEffect(() => {
  getAdvice();
}, []);
```

### 7.2 错误做法

```javascript
// ❌ 错误：不能直接把 async 函数传给 useEffect
useEffect(async () => {
  const data = await fetch("/api/data");
  setData(data);
}, []);

// ❌ 错误：useEffect 的回调函数返回 Promise，不是清理函数
```

**原因**：`useEffect` 的回调函数返回值应该是清理函数，而 `async` 函数返回的是 Promise。

---

## 8. 清理函数（Cleanup Function）

当需要在组件卸载或重新执行副作用前清理时，返回一个清理函数：

```javascript
useEffect(() => {
  // 设置订阅
  const subscription = subscribe();

  // 返回清理函数
  return () => {
    subscription.unsubscribe();  // 清理订阅
  };
}, []);
```

**执行时机**：

```
┌─────────────────────────────────────────────────────────┐
│              清理函数的执行时机                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  组件卸载时：                                              │
│  ─────────────────────────────────────                  │
│  副作用执行 → 组件运行 → 组件卸载 → 清理函数执行            │
│                                                         │
│  依赖变化重新执行前：                                      │
│  ─────────────────────────────────────                  │
│  副作用执行 → 依赖变化 → 清理函数执行 → 新副作用执行        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 9. API 说明

本示例使用的 API：

| 属性 | 值 |
|---|---|
| **URL** | `https://api.adviceslip.com/advice` |
| **方法** | GET |
| **响应格式** | JSON |

**响应示例**：

```json
{
  "slip": {
    "id": 123,
    "advice": "The early bird catches the worm."
  }
}
```

---

## 10. 小结

本节学习了：

1. ✅ **useEffect 基本语法** - `useEffect(setup, dependencies?)`
2. ✅ **副作用的概念** - 数据获取、定时器、DOM 操作等
3. ✅ **依赖数组的作用** - 控制副作用执行时机
4. ✅ **异步数据获取** - 在 useEffect 中调用异步函数
5. ✅ **加载状态管理** - 使用 isLoading 状态
6. ✅ **清理函数** - 组件卸载时清理副作用

> **核心原则**：
> - 空依赖数组 `[]` = 仅在组件挂载时执行一次
> - 有依赖数组 `[dep]` = 依赖变化时执行
> - 无依赖数组 = 每次渲染后都执行
> - 返回函数 = 清理函数
