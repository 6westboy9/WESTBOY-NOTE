# React 简明教程 - useEffect

本节通过一个**随机建议生成器**应用，学习 React 中最重要的 Hook 之一：`useEffect`。

`useEffect`是 React 提供的内置 Hook，专门用于在**函数组件中处理副作用**。可以把它理解为类组件中 `componentDidMount`（挂载）、`componentDidUpdate`（更新）、`componentWillUnmount`（卸载）这三个生命周期方法的 “组合体”，是函数组件处理非渲染逻辑的核心方式。

## 项目说明

```
lecture-08/final/
├── src/
│   ├── App.jsx       # 主组件（使用 useEffect）
│   └── App.css       # 样式文件
└── package.json      # Vite + React 项目配置
```

> **注意**：本示例使用 Vite + React 开发环境，需要 Node.js 支持。

---

## 1. 完整代码 (App.jsx)

```jsx
import { useEffect, useState } from "react";

function App() {
  const [advice, setAdvice] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  async function getAdvice() {
    setIsLoading(true);

    const response = await fetch("https://api.adviceslip.com/advice");
    const data = await response.json();

    setIsLoading(false);
    setAdvice(data.slip.advice);
  }

  // ⏺ useEffect - 在组件挂载时执行副作用
  useEffect(() => {
    getAdvice();
  }, []);

  return (
    <>
      <h1>Advice</h1>
      <div>{isLoading ? "Loading..." : advice}</div>
      <button onClick={getAdvice}>Get Advice</button>
    </>
  );
}

export default App;
```

---

## 2. 什么是副作用？

在 React 组件中，**副作用**指不直接参与 UI 渲染，但需要在组件渲染后执行的操作，常见场景：

| 操作类型                | 示例                                  |
| ------------------- | ----------------------------------- |
| **数据获取**            | `fetch()`、`axios` 请求 API            |
| **定时器**             | `setTimeout`、`setInterval`          |
| **手动 DOM 操作**       | `document.querySelector()`、直接修改 DOM |
| **订阅事件**            | `addEventListener`、WebSocket 连接     |
| **写入 localStorage** | `localStorage.setItem()`            |

```javascript
// 副作用示例
useEffect(() => {
  // 数据获取（副作用）
  fetch("/api/data").then(res => res.json());

  // 定时器（副作用）
  const timer = setTimeout(() => {}, 1000);

  // 订阅事件（副作用）
  window.addEventListener("resize", handleResize);

  // 清理函数
  return () => {
    clearTimeout(timer);
    window.removeEventListener("resize", handleResize);
  };
}, []);
```

---

## 3. useEffect 语法

```javascript
useEffect(setup, dependencies?)
```

| 参数 | 类型 | 说明 |
|---|---|---|
| `setup` | `() => (cleanup \| undefined)` | 副作用函数，可选返回清理函数 |
| `dependencies` | `Array<any>` | 依赖数组，可选 |

### 3.1 基本用法

```javascript
import { useEffect } from 'react';

function MyComponent() {
  // 核心语法：useEffect(副作用函数, 依赖项数组)
  useEffect(() => {
    // 1. 这里写要执行的副作用逻辑（如请求数据、修改DOM）
    
    // 2. 可选：返回一个清理函数（用于卸载/重新执行前清理资源）
    return () => {
      // 清理逻辑（如清除定时器、取消订阅）
    };
  }, [依赖项1, 依赖项2]); // 依赖项数组：控制副作用的执行时机

  return <div>组件内容</div>;
}
```

---

## 4. 依赖数组详解

依赖项数组是 `useEffect` 的核心，决定副作用何时执行，分 4 种常见情况：

| 依赖项数组写法        | 执行时机                   | 对应类组件生命周期                              |
| -------------- | ---------------------- | -------------------------------------- |
| 不写（省略）         | 组件**每次渲染**（初始 + 更新）后执行 | componentDidMount + componentDidUpdate |
| 空数组 `[]`       | 仅组件**首次挂载**后执行 1 次     | componentDidMount                      |
| 包含特定值 `[a, b]` | 仅当`a`或`b`的值发生变化时执行     | 自定义的 componentDidUpdate                |

### 4.1 示例 1：仅挂载时执行

```js
import { useEffect } from 'react';

function Home() {
  // 空依赖数组：仅首次挂载执行
  useEffect(() => {
    document.title = '首页 - React应用'; // 修改DOM的副作用
  }, []); // 无依赖，只执行1次

  return <h1>欢迎来到首页</h1>;
}
```


### 4.2 示例 2：依赖变化时执行

```js
import { useState, useEffect } from 'react';

function UserDetail({ userId }) {
  const [user, setUser] = useState(null);

  // 依赖userId：只有userId变化时，重新请求数据
  useEffect(() => {
    // 副作用：请求用户数据
    const fetchUser = async () => {
      const res = await fetch(`https://api.example.com/users/${userId}`);
      const data = await res.json();
      setUser(data);
    };

    fetchUser();

    // 清理函数：如果请求还没完成，组件卸载/重新执行时取消请求
    return () => {
      // 简化示例：实际项目可使用AbortController取消fetch请求
      console.log(`取消userId=${userId}的请求`);
    };
  }, [userId]); // 依赖userId，变化则重新执行

  if (!user) return <div>加载中...</div>;
  return <div>用户名：{user.name}</div>;
}
```


### 4.3 清理函数

```js
import { useState, useEffect } from 'react';

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 副作用：设置定时器
    const timer = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);

    // 清理函数：组件卸载时清除定时器（避免内存泄漏）
    return () => {
      clearInterval(timer);
    };
  }, []); // 空依赖，定时器只创建1次

  return <div>已计时：{count}秒</div>;
}
```




---
## 5. 本例代码详解

### 5.1 状态定义

```javascript
const [advice, setAdvice] = useState("");           // 存储建议内容
const [isLoading, setIsLoading] = useState(false); // 加载状态
```

### 5.2 异步获取数据

```javascript
async function getAdvice() {
  setIsLoading(true);  // 开始加载

  // 调用 API 获取随机建议
  const response = await fetch("https://api.adviceslip.com/advice");
  const data = await response.json();

  setIsLoading(false); // 加载完成
  setAdvice(data.slip.advice); // 更新建议内容
}
```

### 5.3 useEffect 的使用

```javascript
useEffect(() => {
  getAdvice();  // 组件挂载时自动获取建议
}, []);         // 空依赖数组 = 只执行一次
```

**执行时机**：

```
┌─────────────────────────────────────────────────────────┐
│                   组件生命周期                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 组件挂载                                              │
│     ↓                                                    │
│  2. useEffect 执行 → getAdvice()                         │
│     ↓                                                    │
│  3. 开始加载 (isLoading = true)                          │
│     ↓                                                    │
│  4. API 请求返回                                          │
│     ↓                                                    │
│  5. 更新状态 (advice, isLoading)                         │
│     ↓                                                    │
│  6. 重新渲染显示建议                                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 6. 条件渲染

```javascript
<div>
  {isLoading ? "Loading..." : advice}
</div>
```

| isLoading 值 | 显示内容 |
|---|---|
| `true` | 显示 "Loading..." |
| `false` | 显示获取的建议内容 |

---

## 7. useEffect 与异步操作

### 7.1 正确做法

```javascript
// ✅ 推荐：在 useEffect 中调用独立的异步函数
useEffect(() => {
  async function fetchData() {
    const data = await fetch("/api/data");
    setData(data);
  }
  fetchData();
}, []);

// ✅ 推荐：使用外部定义的异步函数
useEffect(() => {
  getAdvice();
}, []);
```

### 7.2 错误做法

```javascript
// ❌ 错误：不能直接把 async 函数传给 useEffect
useEffect(async () => {
  const data = await fetch("/api/data");
  setData(data);
}, []);

// ❌ 错误：useEffect 的回调函数返回 Promise，不是清理函数
```

**原因**：`useEffect` 的回调函数返回值应该是清理函数，而 `async` 函数返回的是 Promise。

---

## 8. 清理函数（Cleanup Function）

当需要在组件卸载或重新执行副作用前清理时，返回一个清理函数：

```javascript
useEffect(() => {
  // 设置订阅
  const subscription = subscribe();

  // 返回清理函数
  return () => {
    subscription.unsubscribe();  // 清理订阅
  };
}, []);
```

**执行时机**：

```
┌─────────────────────────────────────────────────────────┐
│              清理函数的执行时机                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  组件卸载时：                                              │
│  ─────────────────────────────────────                  │
│  副作用执行 → 组件运行 → 组件卸载 → 清理函数执行            │
│                                                         │
│  依赖变化重新执行前：                                      │
│  ─────────────────────────────────────                  │
│  副作用执行 → 依赖变化 → 清理函数执行 → 新副作用执行        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 9. API 说明

本示例使用的 API：

| 属性 | 值 |
|---|---|
| **URL** | `https://api.adviceslip.com/advice` |
| **方法** | GET |
| **响应格式** | JSON |

**响应示例**：

```json
{
  "slip": {
    "id": 123,
    "advice": "The early bird catches the worm."
  }
}
```

---

## 10. 小结

本节学习了：

1. ✅ **useEffect 基本语法** - `useEffect(setup, dependencies?)`
2. ✅ **副作用的概念** - 数据获取、定时器、DOM 操作等
3. ✅ **依赖数组的作用** - 控制副作用执行时机
4. ✅ **异步数据获取** - 在 useEffect 中调用异步函数
5. ✅ **加载状态管理** - 使用 isLoading 状态
6. ✅ **清理函数** - 组件卸载时清理副作用

> **核心原则**
> - 空依赖数组 `[]` = 仅在组件挂载时执行一次
> - 有依赖数组 `[dep]` = 依赖变化时执行
> - 无依赖数组 = 每次渲染后都执行
> - 返回函数 = 清理函数

>**关键注意事项**
> - **避免无限循环**：如果在`useEffect`中修改了依赖项数组中的值（如`setState`修改 state），且依赖项数组包含该值，会导致无限执行。解决：确保依赖项仅包含 “真正需要触发副作用” 的值。
> - **执行时机**：`useEffect`的副作用函数在浏览器**完成 DOM 渲染后异步执行**，不会阻塞页面渲染（如果需要同步执行，可使用`useLayoutEffect`）。
> - **清理函数执行时机**：
	- 组件卸载时执行；
	- 副作用函数重新执行前（依赖项变化）执行。