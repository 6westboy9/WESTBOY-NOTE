# React 简明教程 - 第三节：派生状态 (Derived State)

本节通过带验证的登录表单，学习**派生状态**的概念——即根据现有状态计算得出的值。

## 项目结构

```
lecture-03/
├── index.html    # HTML 入口文件
├── main.js       # React 组件逻辑
└── style.css     # 样式文件
```

---

## 1. HTML 入口文件 (index.html)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- React 核心库 -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <!-- ReactDOM 库 -->
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel 转译器 -->
    <script type="text/javascript" src="https://unpkg.com/babel-standalone@6/babel.js"></script>
    <link rel="stylesheet" href="./style.css" />
    <title>Document</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="text/babel" src="./main.js"></script>
  </body>
</html>
```

> **注意**：挂载容器的 ID 改为 `app`（之前是 `root`）。

---

## 2. React 组件代码 (main.js)

```javascript
function AppContent() {
  // 定义两个基础状态：用户名和密码
  const [username, setUsername] = React.useState("");
  const [password, setPassword] = React.useState("");

  // ⏺ 派生状态 (Derived State)
  //    根据基础状态计算得出，不需要单独使用 useState，类似 Vue 中的计算属性
  const usernameClass = username.length <= 5 ? "input-error" : "input";
  const passwordClass = password.length <= 5 ? "input-error" : "input";

  function handleSubmit(event) {
    event.preventDefault();

    // 使用派生状态进行验证
    if (
      usernameClass === "input-error" ||
      passwordClass === "input-error"
    ) {
      return; // 验证失败，不提交
    }

    console.log("username: ", username);
    console.log("password: ", password);

    // 清空表单
    setUsername("");
    setPassword("");
  }

  return (
    <main>
      <h2>Login Form</h2>
      <form onSubmit={handleSubmit} style={{ textAlign: "center" }}>
        <input
          className={usernameClass}
          type="text"
          value={username}
          onChange={(event) => setUsername(event.target.value)}
        />
        <br />
        <input
          className={passwordClass}
          type="password"
          value={password}
          onChange={(event) => setPassword(event.target.value)}
        />
        <br />
        <button type="submit" className="btn">
          Login
        </button>
      </form>
    </main>
  );
}

const appEl = document.querySelector("#app");
const root = ReactDOM.createRoot(appEl);
root.render(<AppContent />);
```

---

## 3. 样式文件 (style.css)

```css
.input {
  margin: 2px;
}

.input-error {
  border: 1px solid red;  /* 验证失败时显示红色边框 */
}

.btn {
  margin: 1rem;
}

h2 {
  text-align: center;
}

main {
  border: 1px solid black;
}
```

---

## 4. 核心概念解析

### 4.1 什么是派生状态？

**派生状态**是根据现有状态计算得出的值，不需要使用 `useState` 单独存储。

```javascript
// ❌ 错误做法：为派生状态单独使用 useState
const [usernameClass, setUsernameClass] = React.useState("input-error");
useEffect(() => {
  setUsernameClass(username.length <= 5 ? "input-error" : "input");
}, [username]);

// ✅ 正确做法：直接计算派生状态
const usernameClass = username.length <= 5 ? "input-error" : "input";
```

### 4.2 为什么使用派生状态？

| 方面 | 派生状态 | 额外的 useState |
|---|---|---|
| **代码量** | 简洁，一行计算 | 需要 useEffect 同步 |
| **一致性** | 始终与源状态同步 | 可能出现不同步 |
| **性能** | 每次渲染重新计算（很快） | 额外的渲染周期 |
| **维护性** | 逻辑清晰，易于理解 | 代码分散，难维护 |

### 4.3 派生状态的数据流

```
┌─────────────────────────────────────────────────────────────┐
│                         组件渲染                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   基础状态                    派生状态                        │
│  ┌──────────┐              ┌──────────┐                     │
│  │ username │ ─────────►   │   根据    │                     │
│  │ password │    length    │ username  │                     │
│  └──────────┘              │ 计算 class │                     │
│                            └──────────┘                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.4 派生状态的使用场景

| 场景 | 示例 |
|---|---|
| **格式化显示** | `const formatted = date.toLocaleDateString()` |
| **过滤列表** | `const filtered = items.filter(item => item.active)` |
| **计算总值** | `const total = items.reduce((sum, item) => sum + item.price, 0)` |
| **验证状态** | `const isValid = email.includes('@')` |
| **样式类名** | `const className = hasError ? 'error' : 'normal'` |

---

## 5. 本例中的派生状态详解

```javascript
// 派生状态：根据输入长度决定样式类
const usernameClass = username.length <= 5 ? "input-error" : "input";
const passwordClass = password.length <= 5 ? "input-error" : "input";
```

| 输入长度 | 派生状态值 | 样式效果 |
|---|---|---|
| ≤ 5 | `"input-error"` | 红色边框 |
| > 5 | `"input"` | 默认样式 |

```javascript
// 在提交时使用派生状态进行验证
if (
  usernameClass === "input-error" ||
  passwordClass === "input-error"
) {
  return; // 阻止提交
}
```

---

## 6. 运行效果

| 场景 | 行为 |
|---|---|
| 输入 ≤ 5 个字符 | 输入框显示红色边框 |
| 输入 > 5 个字符 | 输入框恢复正常样式 |
| 点击 Login（有输入错误） | 不提交，不刷新页面 |
| 点击 Login（验证通过） | 控制台输出，清空表单 |

---

## 7. 小结

本节学习了：

1. ✅ **派生状态概念** - 根据现有状态计算得出的值
2. ✅ **为什么使用派生状态** - 避免冗余状态，保持数据同步
3. ✅ **派生状态 vs useState** - 理解何时使用哪种方式
4. ✅ **实际应用场景** - 样式计算、表单验证、数据过滤等
5. ✅ **数据一致性** - 派生状态始终与源状态保持同步

> **核心原则**：如果一个值可以通过其他状态计算得出，就不要为它创建单独的状态。
