# React 简明教程 - 组件抽象

本节通过一个**时间显示 + 随机建议**应用，学习 React 中的组件抽象技巧：**自定义 Hook** 和 **组件拆分**。

组件抽象是 React 开发中的核心能力，通过将可复用的逻辑抽取到自定义 Hook，将可复用的 UI 拆分为独立组件，实现**关注点分离**和**代码复用**。

## 项目说明

```
lecture-10/final/
├── src/
│   ├── App.jsx        # 主组件
│   ├── Time.jsx       # 时间组件（使用 useTime Hook）
│   ├── Advice.jsx     # 建议组件（使用 useAdvice Hook）
│   ├── useTime.js     # 自定义 Hook - 时间逻辑
│   └── useAdvice.js   # 自定义 Hook - 建议获取逻辑
└── package.json        # Vite + React 项目配置
```

> **注意**：本示例使用 Vite + React 开发环境，需要 Node.js 支持。

---

## 1. 完整代码

### 1.1 主组件 (App.jsx)

```jsx
import Time from "./Time";
import Advice from "./Advice";

function App() {
  return (
    <>
      <h1>Advice</h1>
      <Time />
      <Advice />
    </>
  );
}

export default App;
```

### 1.2 时间组件 (Time.jsx)

```jsx
import { useTime } from "./useTime";

function Time() {
  const { currentTime } = useTime();

  return <div>{currentTime}</div>;
}

export default Time;
```

### 1.3 时间 Hook (useTime.js)

```javascript
import { useEffect, useState } from "react";

export function useTime() {
  const [currentTime, setCurrentTime] = useState(new Date().toLocaleString());

  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentTime(new Date().toLocaleString());
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, []);

  return { currentTime };
}
```

### 1.4 建议组件 (Advice.jsx)

```jsx
import { useAdvice } from "./useAdvice";

function Advice() {
  const { isLoading, advice, getAdvice, startTime, endTime, duration } = useAdvice();

  return (
    <>
      <div>{isLoading ? "Loading..." : advice}</div>
      <button onClick={getAdvice}>Get Advice</button>
      {startTime && (
        <div style={{ marginTop: "10px", fontSize: "14px", color: "#666" }}>
          <div>开始时间: {startTime}</div>
          {endTime >= startTime && <div>结束时间: {endTime}</div>}
          {endTime >= startTime && duration !== null && <div>耗时: {duration}ms</div>}
        </div>
      )}
    </>
  );
}

export default Advice;
```

### 1.5 建议 Hook (useAdvice.js)

```javascript
import { useEffect, useState } from "react";

export function useAdvice() {
  const [advice, setAdvice] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [startTime, setStartTime] = useState(null);
  const [endTime, setEndTime] = useState(null);
  const [duration, setDuration] = useState(null);

  async function getAdvice() {
    const start = Date.now();
    setStartTime(new Date(start).toLocaleTimeString());
    setIsLoading(true);
    try {
      const response = await fetch("https://api.adviceslip.com/advice");
      const data = await response.json();
      setAdvice(data.slip.advice);
    } catch (error) {
      setAdvice("请求异常");
      console.error("获取建议失败:", error);
    } finally {
      const end = Date.now();
      setEndTime(new Date(end).toLocaleTimeString());
      setDuration(end - start);
      setIsLoading(false);
    }
  }

  useEffect(() => {
    getAdvice();
  }, []);

  return { isLoading, advice, getAdvice, startTime, endTime, duration };
}
```

---

## 2. 什么是组件抽象？

组件抽象是指将复杂组件拆分为更小、更专注的部分，主要包含两个层面：

| 抽象类型 | 作用 | 示例 |
|---------|------|------|
| **UI 抽象** | 将可复用的 UI 拆分为独立组件 | `<Time />`、`<Advice />` |
| **逻辑抽象** | 将可复用的逻辑抽取到自定义 Hook | `useTime()`、`useAdvice()` |

### 2.1 抽象前 vs 抽象后

```
┌─────────────────────────────────────────────────────────────────┐
│                        抽象前 (单组件)                            │
├─────────────────────────────────────────────────────────────────┤
│  function App() {                                               │
│    // 时间相关状态                                               │
│    const [currentTime, setCurrentTime] = useState(...);         │
│    useEffect(() => { setInterval(...) }, []);                   │
│                                                                 │
│    // 建议相关状态                                               │
│    const [advice, setAdvice] = useState(...);                   │
│    const [isLoading, setIsLoading] = useState(...);             │
│    useEffect(() => { getAdvice() }, []);                        │
│                                                                 │
│    return (                                                     │
│      <>                                                         │
│        <div>{currentTime}</div>                                 │
│        <div>{isLoading ? "Loading..." : advice}</div>           │
│        <button onClick={getAdvice}>Get Advice</button>          │
│      </>                                                        │
│    );                                                           │
│  }                                                              │
└─────────────────────────────────────────────────────────────────┘

                              ↓ 抽象

┌─────────────────────────────────────────────────────────────────┐
│                        抽象后 (多层结构)                          │
├─────────────────────────────────────────────────────────────────┤
│  function App() {                                               │
│    return (                                                     │
│      <>                                                         │
│        <Time />        ← 时间组件（封装时间逻辑）                   │
│        <Advice />      ← 建议组件（封装建议逻辑）                   │
│      </>                                                        │
│    );                                                           │
│  }                                                              │
│                                                                 │
│  // useTime() Hook      → 封装时间更新逻辑                        │
│  // useAdvice() Hook    → 封装 API 请求逻辑                       │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 自定义 Hook

### 3.1 什么是自定义 Hook？

自定义 Hook 是一个函数，名称以 `use` 开头，可以在内部调用其他 Hook。

```javascript
// 自定义 Hook 的命名规范：use + 功能名称
function useXxx() {
  // 可以使用 useState、useEffect 等内置 Hook
  const [state, setState] = useState();

  useEffect(() => {
    // 副作用逻辑
  }, []);

  // 返回状态或函数
  return { state };
}
```

### 3.2 为什么需要自定义 Hook？

| 场景 | 不使用 Hook | 使用自定义 Hook |
|-----|------------|---------------|
| **代码复用** | 每个 component 重复写相同逻辑 | 抽取到 Hook，多处复用 |
| **关注点分离** | UI 和逻辑混在一起 | UI 组件专注渲染，Hook 专注逻辑 |
| **测试性** | 组件逻辑难以单独测试 | Hook 可独立测试 |

### 3.3 自定义 Hook 示例

```javascript
// ❌ 不使用 Hook - 逻辑分散在组件中
function Timer() {
  const [time, setTime] = useState(0);
  useEffect(() => {
    const timer = setInterval(() => setTime(t => t + 1), 1000);
    return () => clearInterval(timer);
  }, []);
  return <div>{time}秒</div>;
}

// ✅ 使用自定义 Hook - 逻辑可复用
function useTimer() {
  const [time, setTime] = useState(0);
  useEffect(() => {
    const timer = setInterval(() => setTime(t => t + 1), 1000);
    return () => clearInterval(timer);
  }, []);
  return time;
}

function Timer() {
  const time = useTimer();  // 简洁！
  return <div>{time}秒</div>;
}
```

---

## 4. useTime Hook 详解

### 4.1 代码结构

```javascript
export function useTime() {
  // 1. 状态定义
  const [currentTime, setCurrentTime] = useState(new Date().toLocaleString());

  // 2. 副作用：每秒更新时间
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentTime(new Date().toLocaleString());
    }, 1000);

    // 3. 清理：组件卸载时清除定时器
    return () => {
      clearInterval(interval);
    };
  }, []);

  // 4. 返回状态
  return { currentTime };
}
```

### 4.2 执行流程

```
┌─────────────────────────────────────────────────────────────────┐
│                     useTime Hook 执行流程                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 组件挂载                                                      │
│     ↓                                                           │
│  2. 调用 useTime()                                               │
│     ↓                                                           │
│  3. 初始化 currentTime = "2024/1/1 12:00:00"                    │
│     ↓                                                           │
│  4. useEffect 执行，设置定时器                                    │
│     ↓                                                           │
│  5. 每秒触发 → 更新 currentTime                                   │
│     ↓                                                           │
│  6. 组件重新渲染，显示新时间                                       │
│     ↓                                                           │
│  7. 组件卸载时 → clearInterval 清理定时器                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. useAdvice Hook 详解

### 5.1 状态管理

```javascript
const [advice, setAdvice] = useState("");           // 建议内容
const [isLoading, setIsLoading] = useState(false);  // 加载状态
const [startTime, setStartTime] = useState(null);   // 请求开始时间
const [endTime, setEndTime] = useState(null);       // 请求结束时间
const [duration, setDuration] = useState(null);     // 请求耗时
```

### 5.2 异步请求逻辑

```javascript
async function getAdvice() {
  // 记录开始时间
  const start = Date.now();
  setStartTime(new Date(start).toLocaleTimeString());
  setIsLoading(true);

  try {
    // 发送请求
    const response = await fetch("https://api.adviceslip.com/advice");
    const data = await response.json();
    setAdvice(data.slip.advice);
  } catch (error) {
    // 错误处理
    setAdvice("请求异常");
    console.error("获取建议失败:", error);
  } finally {
    // 记录结束时间和耗时
    const end = Date.now();
    setEndTime(new Date(end).toLocaleTimeString());
    setDuration(end - start);
    setIsLoading(false);
  }
}
```

### 5.3 初始化请求

```javascript
useEffect(() => {
  getAdvice();  // 组件挂载时自动获取建议
}, []);
```

### 5.4 返回值

```javascript
return {
  isLoading,    // 加载状态
  advice,       // 建议内容
  getAdvice,    // 重新获取函数
  startTime,    // 开始时间
  endTime,      // 结束时间
  duration      // 耗时（毫秒）
};
```

---

## 6. 组件拆分原则

### 6.1 何时拆分组件？

| 情况 | 示例 |
|-----|------|
| UI 在多处复用 | 按钮、卡片、表单控件 |
| 逻辑独立 | 时间显示、数据获取 |
| 组件过于复杂 | 超过 200 行，职责过多 |

### 6.2 拆分后的优势

```
┌─────────────────────────────────────────────────────────────────┐
│                        拆分前                                    │
├─────────────────────────────────────────────────────────────────┤
│  function App() {                                               │
│    // 300+ 行代码                                                │
│    // 包含：时间逻辑 + 建议逻辑 + UI 渲染                         │
│  }                                                              │
│                                                                 │
│  问题：                                                          │
│  • 代码难以理解                                                  │
│  • 逻辑难以复用                                                  │
│  • 难以测试                                                      │
│  • 修改一处可能影响其他功能                                       │
└─────────────────────────────────────────────────────────────────┘

                              ↓ 拆分

┌─────────────────────────────────────────────────────────────────┐
│                        拆分后                                    │
├─────────────────────────────────────────────────────────────────┤
│  App.jsx          → 组合组件（~15 行）                           │
│  Time.jsx         → 时间 UI（~10 行）                            │
│  Advice.jsx       → 建议 UI（~25 行）                            │
│  useTime.js       → 时间逻辑（~20 行）                           │
│  useAdvice.js     → 建议逻辑（~40 行）                           │
│                                                                 │
│  优势：                                                          │
│  • 每个文件职责单一，易于理解                                     │
│  • Hook 可在多个组件中复用                                        │
│  • 可单独测试 Hook 和组件                                         │
│  • 修改互不影响                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. 抽象的层次关系

```
┌─────────────────────────────────────────────────────────────────┐
│                     组件抽象层次                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  UI 层 (Components)                                        │ │
│  │  ┌─────────────────┐  ┌─────────────────┐                 │ │
│  │  │   Time.jsx      │  │   Advice.jsx    │                 │ │
│  │  │   (时间显示)     │  │   (建议显示)     │                 │ │
│  │  └─────────────────┘  └─────────────────┘                 │ │
│  └───────────────────────────────────────────────────────────┘ │
│              ↓ 依赖                     ↓ 依赖                   │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  Logic 层 (Custom Hooks)                                  │ │
│  │  ┌─────────────────┐  ┌─────────────────┐                 │ │
│  │  │   useTime()     │  │   useAdvice()   │                 │ │
│  │  │   (定时器逻辑)   │  │   (API 请求)    │                 │ │
│  │  └─────────────────┘  └─────────────────┘                 │ │
│  └───────────────────────────────────────────────────────────┘ │
│              ↓ 依赖                     ↓ 依赖                   │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  React 内置层 (Built-in Hooks)                            │ │
│  │  ┌─────────────────┐  ┌─────────────────┐                 │ │
│  │  │   useState()    │  │   useEffect()   │                 │ │
│  │  └─────────────────┘  └─────────────────┘                 │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. 小结

本节学习了：

1. ✅ **组件抽象的概念** - UI 抽象 + 逻辑抽象
2. ✅ **自定义 Hook** - 以 `use` 开头的函数，可复用逻辑
3. ✅ **组件拆分原则** - 单一职责、可复用、易测试
4. ✅ **关注点分离** - UI 组件专注渲染，Hook 专注逻辑
5. ✅ **Hook 返回值** - 可返回状态、函数等任意值

> **核心原则**
> - 自定义 Hook 命名必须以 `use` 开头
> - Hook 只能在函数组件或其他 Hook 中调用
> - 每次调用 Hook 都有独立的状态（不会共享状态）
> - 组件应该尽量简洁，复杂逻辑抽取到 Hook

> **何时使用自定义 Hook**
> - 多个组件需要相同的逻辑
> - 组件逻辑过于复杂，需要分离
> - 需要独立测试某部分逻辑
