# CPU

## 物理核与逻辑核

超线程（Hyper-Threading）技术可以让一个物理核在单位时间内同时处理两个线程，变成两个逻辑核。但它不会拥有传统单核2倍的处理能力，也不可能提供完整的并行处理能力。

**超线程技术CPU结构示意图**

![[Pasted image 20231229164426.png|400]]

举个例子，假设一个CPU芯片就是一个班级；它有2个物理核，也就是2个同学，老师让他们分别担任班长和体育委员；过了一段时间，校长要求每个班级还要有学习委员和生活委员，理论上还需要2位同学，但是这个班级只有2个人，最后老师只能让班长和体育委员兼任。

这样一来，对于不了解的人来说，这个班级有班长、体育委员、学习委员和生活委员4个职位，应该有4个人，每个职位就是一个逻辑核；但是，实际上这个班级只有2位同学，也就是只有2个物理核，虽然他们可以做4份工作，但是不能把他们当做4个人。

![[Pasted image 20231229164506.png|600]]

## 查询CPU信息

```shell
$ cat /proc/cpuinfo
```

![[Pasted image 20231229163124.png|1200]]

 * 总核数 = 物理CPU个数 × 每个物理CPU的核数
 * 总逻辑CPU数 = 物理CPU个数 × 每个物理CPU的核数 × 超线程数

```shell
# 查看CPU物理个数
$ cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l
12

# 查看每个物理CPU核数
$ cat /proc/cpuinfo | grep "cpu cores" | uniq
cpu cores	: 1

# 查看每个物理CPU逻辑核数（是不是可以理解为超线程数）
$ cat /proc/cpuinfo | grep "siblings" | uniq
siblings	: 1

# 查看逻辑CPU的个数
$ cat /proc/cpuinfo | grep "processor" | wc -l
12
```

# 平均负载

## 基础概念

平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数（*意思是这两个状态的进程数之和的平均值？暂且这么理解吧*），也就是平均活跃进程数，**它和CPU使用率并没有直接关系**。
* 可运行状态的进程：指正在使用CPU或者正在等待CPU的进程，也就是我们常用ps命令看到的，处于R状态（Running或Runnable）的进程。
* 不可中断状态的进程：指正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的I/O响应，也就是我们在ps命令中看到的D状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。

比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。

**平均负载**其实就是平均活跃进程数。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。这个指数衰减平均的详细含义你不用计较，这只是系统的一种更快速的计算方式，你把它直接当成活跃进程数的平均值也没问题。既然平均的是活跃进程数，那么<u>最理想的就是每个CPU上都刚好运行着一个进程</u>，这样每个CPU都得到了充分利用。

比如当平均负载为2时，意味着什么呢？
- 在只有2个CPU的系统上，意味着所有的CPU都刚好被完全占用。
- 在4个CPU的系统上，意味着CPU有50%的空闲。
- 而在只有1个CPU的系统中，则意味着有一半的进程竞争不到CPU。

>上面所说的CPU个数都是指逻辑CPU个数

## 平均负载合理范围

我们知道，平均负载最理想的情况是等于CPU个数。所以在评判平均负载时，首先你要知道系统有几个CPU，这可以通过top命令或者从文件/proc/cpuinfo中读取，比如：

```shell
# 查看逻辑CPU的个数
$ cat /proc/cpuinfo | grep "processor" | wc -l
12
```

有了CPU个数，我们就可以判断出，当平均负载比CPU个数还大的时候，系统已经出现了过载。不过，我们在例子中可以看到，平均负载有三个数值，到底该参考哪一个呢？

实际上，都要看。三个不同时间间隔的平均值，其实给我们提供了，分析系统负载趋势的数据来源，让我们能更全面、更立体地理解目前的负载状况。

- 如果1分钟、5分钟、15分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。
- 如果1分钟的值远小于15分钟的值，就说明系统最近1分钟的负载在减少，而过去15分钟内却有很大的负载。
- 如果1分钟的值远大于15分钟的值，就说明最近1分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦1分钟的平均负载接近或超过了CPU的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。

## 平均负载与CPU使用率

现实工作中，我们经常容易把平均负载和CPU使用率混淆，所以在这里，我也做一个区分。可能你会疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，不就意味着CPU使用率高吗？我们还是要回到平均负载的含义上来，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用CPU的进程，还包括等待CPU和等待I/O的进程。而CPU使用率，是单位时间内CPU繁忙情况的统计，跟平均负载并不一定完全对应。

两者不能等同，有两种常见的场景如下所述：
- CPU密集型应用，大量进程在等待或使用CPU，此时CPU使用率与平均负载呈正相关状态。
- I/O密集型应用，大量进程在等待I/O，此时平均负载会升高，但CPU使用率不一定很高。

为了更深入的理解CPU使用率与平均负载的关系，我们举一个例子：假设现在有一个电话亭，有4个人在等待打电话，电话亭同一时刻只能容纳1个人打电话，只有拿起电话筒才算是真正使用。那么CPU使用率就是拿起电话筒的时间占比，它只取决于在电话亭里的人的行为，与平均负载没有非常直接的关系。而平均负载是指在电话亭里的人加上排队的总人数，如下图所示:

![[Pasted image 20231229165655.png|1000]]

补充案例：

* [漫话性能：CPU平均负载](https://zhuanlan.zhihu.com/p/183950608)
* [干货篇 | 关于平均负载和CPU使用率，看完你就掌握了](https://zhuanlan.zhihu.com/p/384468564)

# 内存

```shell
$ free -mh
              total        used        free      shared  buff/cache   available
Mem:            15G         14G        205M         87M        897M        702M
Swap:           31G        5.1G         26G
```

其中， -m选项是以MB为单位来展示内存使用信息； -h选项则是以人类可读的单位来展示。

上面的示例中Mem这一行：
* total：表示总共有15G的物理内存(RAM)。
* used：表示物理内存的使用量，大约是14G。
* free：表示空闲内存；
* shared：表示共享内存；
* buff/cache：表示缓存和缓冲内存量；Linux系统会将很多东西缓存起来以提高性能，这部分内存可以在必要时进行释放，给其他程序使用。
* available：表示可用内存；

输出结果很容易理解。 Swap这一行表示交换内存，从示例中的数字可以看到，使用到交换内存挺多的，达到5.1G。
# 监控
## top

![[Pasted image 20231229154018.png|600]]

*load average: 0.78, 0.85, 0.87*

关于平均负载的详细说明见：[[系统负载#平均负载]]

其实可以通过如下命令查看平均负载：

```shell
$ watch -d uptime
```

## htop

```shell
$ yum install -y htop
$ htop
```

![[Pasted image 20231229153938.png|1100]]

## netdata

Netdata是一款Linux性能实时监测工具。

https://www.netdata.cloud

**1.安装**

```shell
yum install epel-release -y
yum install netdata -y
```

**2.修改配置**

```shell
vim /etc/netdata/netdata.conf
```

这里只列举改动项：

```shell
[global]
    run as user = root
[web]
    web files owner = root
    web files group = root
    bind to = 10.2.3.170
```

**3.启动**

```shell
service netdata start
```

**4.访问**

http://10.2.3.170:19999

大致如下：

![[Pasted image 20231229170839.png|1100]]