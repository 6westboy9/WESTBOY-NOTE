# 推荐资料

* [官方文档-开发者手册-数据分片](https://shardingsphere.apache.org/document/current/cn/dev-manual/sharding) --- 概述
* [官方文档-用户手册-通用配置-内置算法-分片算法](https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/builtin-algorithm/sharding) --- 详述
* [一口气搞懂分库分表12种分片算法](https://mp.weixin.qq.com/s/YnWVpnORk4QeZWyGQpxtoA)

> [!tip] 下文若无特殊说明均是基于5.4.1版本，最新版本5.5.0~

# 思维导图

ShardingSphere中的分片策略和分片算法

![[Pasted image 20240328111944.png|750]]

>ShardingSphere中自动分片算法和标准分片算法在策略中都是standard，为啥要分为自动和标准两种呢？没有明白其用意
>在[一口气搞懂分库分表12种分片算法](https://mp.weixin.qq.com/s/YnWVpnORk4QeZWyGQpxtoA)中阐述了12种类型算法，但是官方文档中只有上图中10种，那么文中COSID类型算法又是怎么回事呢？

# 分片策略

ShardingSphere对外提供了5种分片策略。<font color="#f79646">不同的分片策略可以搭配使用不同的分片算法</font>，这样可以灵活的应对复杂业务场景。

>分片策略 = 分片键 + 分片算法

| 序号  | 英文名称       | 中文       | 描述                                                                                 | 适用场景                                                  |
| --- | ---------- | -------- | ---------------------------------------------------------------------------------- | ----------------------------------------------------- |
| 1   | `standard` | 标准分片策略   |                                                                                    | 适用于<font color="#c0504d">单一分片</font>键的简单分片场景          |
| 2   | `inline`   | 行表达式分片策略 |                                                                                    | 适用于<font color="#c0504d">单一分片</font>键的简单分片场景          |
| 3   | `complex`  | 复合分片策略   |                                                                                    | 适用于<font color="#c0504d">多个分片</font>键的复杂分片场景          |
| 4   | `hint`     | Hint分片策略 | Hint翻译过来为提示，建议，暗示，线索<br><font color="#f79646">Hint分片策略无需配置分片健，由外部指定分库和分表的信息</font> | 1.分片字段不存在SQL和数据库表结构中，而存在于外部业务逻辑<br>2.强制在指定数据库进行某些数据操作 |
| 5   | `none`     | 不分片策略    | 对逻辑表的所有操作将会执行全库全表路由                                                                |                                                       |
## 1.标准分片策略

```yml
spring:  
  shardingsphere:  
    rules:  
      sharding:  
        tables:  
          t_order: # 逻辑表名称  
            # 数据节点：数据库.分片表  
            actual-data-nodes: db$->{0..1}.t_order_${1..10}  
            # 分库策略  
            databaseStrategy: # 分库策略  
              standard: # 用于单分片键的标准分片场景
                shardingColumn: order_id # 分片列名称  
                shardingAlgorithmName: # 分片算法名称  
            tableStrategy: # 分表策略，同分库策略
```

## 2.行表达式分片策略

```yml
spring:  
  shardingsphere:  
    rules:  
      sharding:  
        tables:  
          t_order: # 逻辑表名称  
            # 数据节点：数据库.分片表  
            actual-data-nodes: db$->{0..1}.t_order_${1..10}  
            # 分库策略  
            databaseStrategy: # 分库策略  
              inline:   # 行表达式类型分片策略  
                algorithm-expression: db$->{order_id % 2} Groovy表达式  
            tableStrategy: # 分表策略，同分库策略
```
## 3.复合分片策略

```yml
spring:  
  shardingsphere:  
    rules:  
      sharding:  
        tables:  
          t_order: # 逻辑表名称  
            # 数据节点：数据库.分片表  
            actual-data-nodes: db$->{0..1}.t_order_${1..10}  
            # 分库策略  
            databaseStrategy: # 分库策略  
              complex: # 用于多分片键的复合分片场景  
                shardingColumns: order_id,user_id # 多个列以逗号分隔  
                shardingAlgorithmName: # 分片算法名称  
            tableStrategy: # 分表策略，同分库策略
```

## 4.Hint分片策略

```yaml
spring:  
  shardingsphere:  
    rules:  
      sharding:  
        tables:  
          t_order: # 逻辑表名称  
            # 数据节点：数据库.分片表  
            actual-data-nodes: db$->{0..1}.t_order_${1..10}  
            # 分库策略  
            databaseStrategy: # 分库策略  
              hint: # Hint分片策略  
                shardingAlgorithmName: # 分片算法名称  
            tableStrategy: # 分表策略，同分库策略
```
## 5.不分片策略

```yml
spring:  
  shardingsphere:  
    rules:  
      sharding:  
        tables:  
          t_order: # 逻辑表名称  
            # 数据节点：数据库.分片表  
            actual-data-nodes: db$->{0..1}.t_order_${1..10}  
            # 分库策略  
            databaseStrategy: # 分库策略  
              none: # 不分片  
           tableStrategy: # 分表策略，同分库策略
```

# 分片算法

> [!missing] 开始前，我要吐槽下官方文档，对于算法这种至关重要的内容，解释描述的过于潦草，对于新手入门不友好，学习成本偏高啊~

## <font color="#9bbb59">01.自动分片算法-取模</font>

最基础的取模算法，它会根据分片字段的值和sharding-count进行取模运算，得到一个结果。

```
表达式 = (分片键/数据库实例) % 分片键数量
```

| 属性名            | 类型  | 描述   | 是否必填 |
| -------------- | --- | ---- | ---- |
| sharding-count | int | 分片数量 | 是    |
| start-offset   |     |      |      |
| stop-offset    |     |      |      |
| zero-padding   |     |      |      |

### 案例

```yaml
# 这里先忽视库路由策略配置
rules:
- !SHARDING
    t_order:
      actualDataNodes: ds_{0..3}.t_order_${0..15}
      tableStrategy:
        standard:
          shardingColumn: order_id
          shardingAlgorithmName: t_order_mode

  shardingAlgorithms:
    t_order_mode:
      type: MOD
      props:
        sharding-count: 16
        start-offset:
        stop-offset:
        zero-padding:
```

## <font color="#9bbb59">02.自动分片算法-哈希取模</font>

和取模算法相同，唯一的区别是针对分片键得到哈希值之后再取模。

```
表达式 = hash(分片键/数据库实例) % 分片键数量
```

| 属性名            | 类型  | 描述   | 是否必填 |
| -------------- | --- | ---- | ---- |
| sharding-count | int | 分片数量 | 是    |
|                |     |      |      |

### 案例

## <font color="#9bbb59">03.自动分片算法-分片容量的范围</font>

分片容量范围，简单理解就是按照某个字段的数值范围进行分片，比如存在下面这样一个需求，怎么配置呢？

```
[0~200)保存到表0
[200~400)保存到表1
[400~600)保存到表2
```

| 属性名             | 类型   | 描述                     | 是否必填 |
| --------------- | ---- | ---------------------- | ---- |
| range-lower     | long | 分片键取值范围下界，超过这个边界的数据会报错 |      |
| range-upper     | long | 分片键取值范围上界，超过这个边界的数据会报错 |      |
| sharding-volume | long | 分片容量，每个分片中存储的数据量       |      |

### 案例

## <font color="#9bbb59">04.自动分片算法-分片边界的范围</font>

前面讲的分片容量范围分片，是一个均衡的分片方法，如果<font color="#f79646">存在不均衡</font>的场景，比如下面这种情况：

```
[0~1000)保存到表0
[1000~20000)保存到表1
[20000~300000)保存到表2
[300000~无穷大)保存到表3
```

| 属性名 | 类型 | 描述 | 是否必填 |
| ---- | ---- | ---- | ---- |
|  |  |  |  |
|  |  |  |  |

### 案例

## <font color="#9bbb59">05.自动分片算法-可变时间范围</font>

根据时间段进行分片，如果想实现如下功能：

```
(1970-01-01 23:59:59 ~ 2020-01-01 23:59:59) 表0
[2020-01-01 23:59:59 ~ 2021-01-01 23:59:59) 表1
[2021-01-01 23:59:59 ~ 2022-02-01 23:59:59) 表2
[2022-01-01 23:59:59 ~ 2024-01-01 23:59:59) 表3
```



| 属性名 | 类型 | 描述 | 是否必填 |
| ---- | ---- | ---- | ---- |
| datetime-lower | String | 分片时间开始边界，格式固定：yyyy-MM-dd HH:mm:ss | 是 |
| datetime-upper | String | 分片时间结束边界，格式固定：yyyy-MM-dd HH:mm:ss | 是 |
| sharding-seconds | long | 按多少秒一个分片进行分片 | 是 |

### 案例

```yaml
shardingAlgorithms:
  date-sharding-algorithm:
    type: AUTO_INTERVAL
    props:
      datetime-lower: "2022-01-01 00:00:00"
      datetime-upper: "2023-01-01 00:00:00"
      sharding-seconds: 86400
```


## <font color="#c0504d">06.标准分片算法-固定时间范围</font> @DONE

>实现：org.apache.shardingsphere.sharding.algorithm.sharding.datetime.IntervalShardingAlgorithm

| 属性名 | 类型 | 描述 | 是否必填 |
| ---- | ---- | ---- | ---- |
| datetime-pattern | String | 配置分片开始和结束时间格式 | 是 |
| datetime-lower | String | 分片时间开始边界，格式由datetime-pattern配置 | 是 |
| datetime-upper | String | 分片时间结束边界，格式由datetime-pattern配置 | 否，默认当前时间 |
| sharding-suffix-pattern | String | 时间分片后缀格式，比如t_order_202401，则此处配置的格式应该为：yyyy-MM | 是 |
| datetime-interval-amount | int | 分片时间间隔数量，对应单位由datetime-interval-unit配置 | 否，默认1 |
| datetime-interval-unit | String | java.time.temporal.ChronoUnit枚举类，常见的有：Years，Months，Weeks，Days，Hours | 否，默认 |
#### 案例

```yml
# 这里先忽视库路由策略配置
rules:
- !SHARDING
  tables:
    pat_inhos_order:
      # actualDataNodes: ds_0.pat_inhos_order_${202201..202312} 创建表: 202201,202202...202212,202213,202214...202312 <- 可以看到202213并不是我们希望的
      # 需使用INTERVAL
      # 注意必须为ChronoUnit的name值（必须一致）
      # 表达式语法：https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/builtin-algorithm/expr
      actualDataNodes: <INTERVAL>P=ds_0.pat_inhos_order_;SP=yyyyMM;DIA=1;DIU=Months;DL=202201;DU=202312
      tableStrategy:
        standard:
          shardingColumn: create_time 
          shardingAlgorithmName: pat_inhos_order_interval
  shardingAlgorithms:
    pat_inhos_order_interval:
      type: INTERVAL
      props:
        datetime-pattern: 'yyyy-MM-dd HH:mm:ss'
        datetime-lower: '2022-01-01 00:00:00'
        datetime-upper: '2023-12-31 23:59:59'  
        sharding-suffix-pattern: 'yyyyMM'
        datetime-interval-amount: 1
        # 注意必须为ChronoUnit的name值（不用区分大小写）
        datetime-interval-unit: MONTHS
```

>[!warning] INTERVAL的表达式，ShardingSphere-JDBC 5.4.1包会报错（报错见下），需要基于SPI自行引入~

```log
org.apache.shardingsphere.infra.spi.exception.ServiceProviderNotFoundException: SPI-00001: No implementation class load from SPI `org.apache.shardingsphere.infra.expr.spi.InlineExpressionParser` with type `INTERVAL`.
```

<font color="#f79646">解决方案</font>

![[Pasted image 20240925161052.png|1000]]

>[!warning] actualDataNodes中配置的DIU=Months和分片算法中配置的datetime-interval-unit: MONTHS，两个意思是一样的，取值均来自java.time.temporal.ChronoUnit，不同的是DIU需要与该枚举类的name值严格一致，而datetime-interval-unit不用区分大小写！这...感觉像是个bug~

DEBUG方法org.apache.shardingsphere.sharding.algorithm.sharding.datetime.IntervalShardingAlgorithm#doSharding，查看对应的参数信息：

![[Pasted image 20240130212638.png|1100]]

实际测试发现，<font color="#f79646">这里的availableTargetNams应该是根据actualDataNodes表达式计算得出</font>~

测试验证：

![[Pasted image 20240130212809.png|200]]

按照上述分片策略配置，在实际查询时的SQL如下：

```SQL
-- 这里为了减少日志将实际打印的查询中的映射使用*代替
2024-01-30 21:25:01.417  INFO 14036 --- [           main] ShardingSphere-SQL                       : Logic SQL: select * from pat_inhos_order
2024-01-30 21:25:01.417  INFO 14036 --- [           main] ShardingSphere-SQL                       : Actual SQL: ds_0 ::: select *
    from pat_inhos_order_202201 UNION ALL select *
    from pat_inhos_order_202202 UNION ALL select *
    from pat_inhos_order_202203 UNION ALL select *
    from pat_inhos_order_202204 UNION ALL select *
    from pat_inhos_order_202205 UNION ALL select *
    from pat_inhos_order_202206 UNION ALL select *
    from pat_inhos_order_202207 UNION ALL select *
    from pat_inhos_order_202208 UNION ALL select *
    from pat_inhos_order_202209 UNION ALL select *
    from pat_inhos_order_202210 UNION ALL select *
    from pat_inhos_order_202211 UNION ALL select *
    from pat_inhos_order_202212
```

><font color="#f79646">可见只需要创建一个分片表即可</font>。新的疑问：这个分片表必须是指定表达式范围内吗？还是说我随便创建个表就行呢？

| 测试情况                         | 结果         | 说明                                                                    |
| ---------------------------- | ---------- | --------------------------------------------------------------------- |
| 仅存在pat_inhos_order_202201物理表 | 成功         | 范围内起始表，这里的成功仅仅是说业务代码，ShardingSphere，Mybatis，但是最终执行时，因为物理表不存在肯定还是会报错的！ |
| 仅存在pat_inhos_order_202112物理表 | 报错（错误描述见下） | 范围外                                                                   |
| 仅存在pat_inhos_order_202212物理表 | 报错（错误描述见下） | 范围内截止表                                                                |
错误描述：

```
org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.executor.ExecutorException: Error preparing statement.  Cause: org.apache.shardingsphere.infra.exception.TableNotExistsException: Table or view `pat_inhos_order` does not exist.
```

经过多轮测试，其实只要存在范围内起始表，在JDBC执行前是不会报错的，只是说最终在执行时，因为真实物理表不存在，执行报错~

><font color="#f79646">正确使用：指定范围是哪些就创建对应的物理表！</font>

## <font color="#c0504d">07.标准分片算法-行表达式</font>

| 属性名                                    | 类型      | 描述   | 是否必填      |
| -------------------------------------- | ------- | ---- | --------- |
| algorithm-expression                   | String  | 行表达式 | 是         |
| allow-range-query-with-inline-sharding | boolean |      | 否，默认false |
#### 案例


## <font color="#4f81bd">08.复合分片算法-行表达式的复合分片</font>


org.apache.shardingsphere.sharding.algorithm.sharding.complex.ComplexInlineShardingAlgorithm

| 属性名                                    | 类型      | 描述   | 是否必填      |
| -------------------------------------- | ------- | ---- | --------- |
| algorithm-expression                   | String  | 行表达式 | 是         |
| sharding-columns                       | String  |      | 是         |
| allow-range-query-with-inline-sharding | boolean |      | 否，默认false |
```yaml
shardingAlgorithms:  
  algorithms_name:  
    type: COMPLEX_INLINE  
    props:  
      algorithm-expression: standard  
      sharding-columns: com.lachesis.lachesislog.server.sharding.TimeShardingAlgorithm
      allow-range-query-with-inline-sharding
```

#### 案例

## <font color="#8064a2">09.Hint分片算法-行表达式的Hint分片</font>


org.apache.shardingsphere.sharding.algorithm.sharding.hint.HintInlineShardingAlgorithm

| 属性名                  | 类型  | 描述  | 是否必填 |
| -------------------- | --- | --- | ---- |
| algorithm-expression |     |     |      |
| value                |     |     |      |
### 案例

## <font color="#4bacc6">10.自定义分片算法</font>


org.apache.shardingsphere.sharding.algorithm.sharding.classbased.ClassBasedShardingAlgorithm


| 属性名 | 类型 | 描述 | 是否必填 |
| ---- | ---- | ---- | ---- |
| strategy | String | 可选值：STANDARD，COMPLEX，HINT | 是 |
| algorithmClassName | String | 自定义分片算法类路径 | 是 |

```yaml
shardingAlgorithms:  
  algorithms_name:  
    type: CLASS_BASED  
    props:
	  # TODO 驼峰还是中划线？
      strategy: standard  
      algorithmClassName: com.lachesis.lachesislog.server.sharding.TimeShardingAlgorithm
```

#### 案例


