# 数组的解构赋值


## 基本用法


### 完全匹配


### 嵌套


### 不完全匹配


### 可遍历的结构


## 默认值


# 对象的解构赋值


## 基本用法

### 变量名与属性名一样


```js
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' }; // ⭐️⭐️⭐️ 前者为属性名，后者为变量名
let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; // 变量名与属性名一样时，可简写
```

### 变量名与属性名不一样


```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```

```js
let {foo} = {bar: 'baz'};
foo // undefined
```

### 嵌套赋值一

```js
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p: [x, { y: z }] } = obj;
x // "Hello"
z // "World
```

```js
const node = {
  loc: {
    start: {
      line: 1,
      column: 5
    }
  }
};

let { loc, loc: { start }, loc: { start: { line }} } = node;

// 等同，示例见下截图
// let {loc: loc, loc: {start: start}, loc: {start: {line: line}}} = node;

console.log(line)  // 1
console.log(loc)   // Object {start: Object}
console.log(start) // Object {line: 1, column: 5}
```

可以看到变量的颜色都是蓝色的

![[Pasted image 20240815183543.png|600]]


```js
// TypeError: Cannot read properties of undefined (reading 'bar')
// 原因：foo属性对应是一个子对象，该子对象的bar属性，解构时会报错，因为foo=undefined，取子属性就会报错
let {foo: {bar}} = {baz: 'baz'};

// ok
let {baz: {a: bar}} = {baz: {a: 'baz'}};
// TypeError: Cannot read properties of undefined (reading 'a')
let {foo: {a: bar}} = {baz: {a: 'baz'}};
```

### 嵌套赋值二

```js
let obj = {};
let arr = [];

({foo: obj.prop, bar: arr[0]} = {foo: 123, bar: true});

console.log(obj) // {prop:123}
console.log(arr) // [true]
```

>[!danger] 已经声明的变量用于解构赋值必须放到圆括号里

因为JavaScript引擎会将`{xxx}`理解成一个代码块，从而发生语法错误~

![[Pasted image 20240815185926.png|500]]
### 继承

对象的解构赋值可以取到继承的属性

```js
const obj1 = {};
const obj2 = { foo: 'bar' };
Object.setPrototypeOf(obj1, obj2);

const { foo } = obj1; // 继承自obj2的属性
foo // "bar"
```

### 数组

由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。

```js
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
```


## 允许不防止变量

下面的表达式虽然毫无意义，但是语法是合法的，可以执行。

```js
({} = [true, false]);
({} = 'abc');
({} = []);
```

## 默认值

```js
var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5

var {message: msg = 'Something went wrong'} = {};
msg // "Something went wrong"
```

> [!danger] 默认值生效的条件是，对象的属性值严格等于`undefined`~

```js
var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
```

# 字符串的解构赋值

字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。

```js
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

类似数组的对象都有一个`length`属性，因此还可以对这个属性解构赋值。

```js
let {length : len} = 'hello';
len // 5
```

# 数值和布尔值的解构赋值


# 函数参数的解构赋值



# 圆括号问题


# 用途


## 1.交换变量的值


## 2.从函数返回多个值


## 3.函数参数的定义


## 4.提取JSON数据

```json
let jsonData = {
    id: 42,
    status: "OK",
    data: [867, 5309]
};

let {id, status, data: number} = jsonData;

console.log(id, status, number);
// 42, "OK", [867, 5309]
```

## 5.函数参数的默认值


## 6.便利Map结构

任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。

```json
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}

for (let [key] of map) {
    console.log(key);
}

// 前面','不能少~
for (let [,value] of map) {  
    console.log(value);  
}
```

![[Pasted image 20240815190659.png|400]]
## 7.输入模块的指定方法





