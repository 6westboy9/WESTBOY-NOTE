# <font color="#c0504d">01.模板语法</font>

## 1.文本插值 <font color="#245bdb">{{}}</font>

```html
<span>Message: {{msg}}</span>
```

## 2.原始HTML <font color="#245bdb">v-html</font>

双大括号会将数据解释为纯文本，而不是HTML。若想插入HTML，你需要使用[`v-html`](https://cn.vuejs.org/api/built-in-directives.html#v-html)指令：

```html
<p>Using text interpolation: {{rawHtml}}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

## 3.属性绑定 <font color="#245bdb">v-bind</font>

**双大括号不能在HTML属性中使用**。想要响应式地绑定一个属性，应该使用[`v-bind`](https://cn.vuejs.org/api/built-in-directives.html#v-bind)指令：

```html
<div v-bind:id="dynamicId"></div>
```

v-bind指令指示Vue将元素的id的属性与组件的dynamicId属性保持一致。**如果绑定的值是null或者undefined，那么该属性将会从渲染的元素上移除**。

### 1.简写

```html
<div :id="dynamicId"></div>
```

如果属性名与绑定JavaScript值的名称相同，可以进一步简化语法：

```html
<div :id="id"></div>  // 属性名与JavaScript值的名称相同
<div :id></div>       // 同名简写1 → 仅支持3.4版本及以上
<div v-bind:id></div> // 同名简写2
```


### 2.布尔型属性绑定

布尔型属性依据true/false值来决定属性是否应该存在于该元素上。disabled就是最常见的例子之一。

v-bind在这种场景下的行为略有不同：

```js
<button :disabled="isButtonDisabled">Button</button>
```

当isButtonDisabled为[真值](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)或一个空字符串 (即 `<button disabled="">`) 时，元素会包含这个disabled属性。而当其为其他[假值](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)时，属性将被忽略。

### 3.动态绑定多值

如果你有像这样的一个包含多个属性的JavaScript对象：

```js
const objectOfAttrs = {
  id: 'container',
  class: 'wrapper'
}
```

通过不带参数的v-bind，你可以将它们绑定到单个元素上：

```xml
<div v-bind="objectOfAttrs"></div>
```

## 4.使用JS表达式

至此，我们仅在模板中绑定了一些简单的属性名。但是Vue实际上在所有的数据绑定中都支持完整的JavaScript表达式：

```html
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>
```

这些表达式都会被作为JavaScript ，以当前组件实例为作用域解析执行。

**在Vue模板内JS表达式可以被使用在如下场景**

* 在文本插值中 (双大括号)
* 在任何Vue指令 (以`v-`开头的特殊属性) 属性的值中

### 1.仅支持表达式

每个绑定仅支持**单一表达式**，也就是一段能够被求值的JS代码。因此，下面的例子都是**无效**的：

```html
// 这是一个语句，而非表达式
{{ var a = 1 }}

// 条件控制也不支持，请使用三元表达式
{{ if (ok) { return message } }}
```

### 2.调用函数

可以在绑定的表达式中使用一个组件暴露的方法：

```html
<time :title="toTitleDate(date)" :datetime="date">
  {{ formatDate(date) }}
</time>
```

### 3.受限的全局访问

* 模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如Math和Date。
* 没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在window上的属性。然而，你也可以自行在 `app.config.globalProperties`上显式地添加它们，供所有的Vue表达式使用。

## 5.指令

指令是带有`v-`前缀的特殊属性。

一个指令的任务是在其表达式的值变化时响应式地更新DOM。

```js
<p v-if="seen">Now you see me</p>
```

这里，v-if指令会基于表达式 seen的值的真假来移除/插入该`<p>`元素。

**语法**

![[Pasted image 20241203125759.png|800]]
### 1.指令名称


### 2.指令参数

><font color="#245bdb">1.静态参数</font>

某些指令会需要一个参数，在指令名后通过一个冒号隔开做标识。

```html
<a v-bind:href="url"> ... </a>

<!-- 简写 -->
<a :href="url"> ... </a>
```

这里href就是一个参数，它告诉v-bind指令将表达式url的值绑定到元素的href属性上。

另一个例子是`v-on`指令，它将监听DOM事件：

```html
<a v-on:click="doSomething"> ... </a>

<!-- 简写 -->
<a @click="doSomething"> ... </a>
```

><font color="#245bdb">2.动态参数</font>

同样在指令参数上也可以使用一个JS表达式，需要包含在一对方括号内：

```html
<!-- 注意，参数表达式有一些约束，参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释 -->
<a v-bind:[attributeName]="url"> ... </a>

<!-- 简写 -->
<a :[attributeName]="url"> ... </a>
```

这里的attributeName会作为一个JS表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性attributeName，其值为"href"，那么这个绑定就等价于v-bind:href。

相似地，你还可以将一个函数绑定到动态的事件名称上：

```html
<a v-on:[eventName]="doSomething"> ... </a>

<!-- 简写 -->
<a @[eventName]="doSomething"> ... </a>
```

在此示例中，当eventName的值是"focus"时，就等价于v-on:focus。

>[!note] 动态参数值的限制
>动态参数中表达式的值应当是一个字符串，或者是null。特殊值null意为显式移除该绑定。其他非字符串的值会触发警告。

>[!note] 动态参数语法的限制

动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在HTML属性名称中都是不合法的。例如下面的示例：

```html
<!-- 这会触发一个编译器警告 -->
<a :['foo' + bar]="value"> ... </a>
```

如果你需要传入一个复杂的动态参数，我们推荐使用[计算属性](https://cn.vuejs.org/guide/essentials/computed.html)替换复杂的表达式。

### 3.指令修饰符

# <font color="#c0504d">02.响应式基础</font>


## 1.声明响应式状态

### 1.ref

在组合式API中，推荐使用ref函数来声明响应式状态：

```js
import { ref } from 'vue'

const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

要在组件模板中访问ref，请从组件的setup函数中声明并返回它们：

```js
import { ref } from 'vue'

export default {
  // setup是一个特殊的钩子，专门用于组合式API
  setup() {
    const count = ref(0)

    // 将ref暴露给模板
    return {
      count
    }
  }
}
```

```html
<div>{{ count }}</div>
```

>注意，<font color="#c0504d">只有在JS代码中才能通过添加.value来操作，在模板中使用ref时，我们不需要附加.value</font>。为了方便起见，当在模板中使用时，ref会自动解包 (有一些注意事项)。

你也可以直接在事件监听器中改变一个ref：

```html
<button @click="count++">
  {{ count }}
</button>
```

对于更复杂的逻辑，我们可以在同一作用域内声明更改ref的函数，并将它们作为方法与状态一起公开：

```js
import { ref } from 'vue'

export default {
  setup() {
    const count = ref(0)

    function increment() {
      // 在JavaScript中需要.value
      count.value++
    }

    // 不要忘记同时暴露increment函数
    return {
      count,
      increment
    }
  }
}
```

然后，暴露的方法可以被用作事件监听器：

```html
<button @click="increment">
  {{ count }}
</button>
```

### 2.script setup

在setup函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用单文件组件来避免这种情况。我们可以使用`<script setup>`来大幅度地简化代码：

>单文件组件：[SFC](https://cn.vuejs.org/guide/scaling-up/sfc.html)

```html
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++
}
</script>

<template>
  <button @click="increment">
    {{ count }}
  </button>
</template>
```

>[!important] 在`<script setup>`中的顶层的<font color="#c0504d">导入</font>、<font color="#c0504d">声明的变量</font>和<font color="#c0504d">函数</font>可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个JavaScript函数——它自然可以访问与它一起声明的所有内容。


### 3.为什么要使用ref？


### 4.深层响应性


### 5.DOM更新时机


## 2.reactive

>利用ref函数专门来定义包含<font color="#c0504d">单个数据的响应式对象</font>的方法，那么在应用中如果需要定义包含多个数据的响应式对象该怎么实现呢？

Vue3提供了reactive函数，让开发者可以一次性定义包含多个数据的响应式对象。reactive函数接收一个包含n个基础类型或对象类型属性数据的对象参数，它会返回一个响应式的代理对象，一般我们称此对象为reactive对象​。在JS或模板中可以通过reactive对象直接读取或更新参数对象中的任意属性数据。需要强调一点，<font color="#c0504d">reactive函数进行的是一个深度响应式处理。也就是说，当我们通过reactive对象更新参数对象中的任意层级属性数据后，都会触发页面的自动更新</font>。

```js
import { reactive } from 'vue'

const state = reactive({ count: 0 })
```

在模板中使用：

```html
<button @click="state.count++">
  {{ state.count }}
</button>
```


>先给ref函数传入一个对象或数组数据，再通过ref对象来操作对象或数组的内部数据，发现也是响应式的，这是为什么呢？

因为一旦ref函数内部的value数据是对象或数组，就会自动先创建一个包含此对象或数组的reactive对象，也就是代理对象，再保存给ref对象的value。

```js
const person = ref({name:'Tom',age:12});
person.value.age = 13;
```

更新age属性就是一个响应式的数据更新，因为person.value是ref函数接收的人员信息的reactive对象，也就是代理对象，通过reactive对象去更新对象的内部属性，必然是一个响应式的数据更新，页面自然会更新。


## 3.toRefs与toRef函数


# <font color="#c0504d">04.计算属性</font>


## 方法与计算属性缓存

TODO

## 可写计算属性

<font color="#c0504d">计算属性默认是只读的</font>。当你尝试修改一个计算属性时，你会收到一个运行时警告。<font color="#c0504d">只在某些特殊场景中你可能才需要用到“可写”的属性</font>，你可以通过同时提供getter和setter来创建：

```js
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>
```

# <font color="#c0504d">05.类与样式绑定</font>

## 1.绑定类 <font color="#245bdb">v-bind:class</font>

## 2.绑定内联样式 <font color="#245bdb">v-bind:style</font> 

# <font color="#c0504d">06.条件渲染</font>

## 1.<font color="#245bdb">v-if</font>

## 2.<font color="#245bdb">v-else</font>

## 3.<font color="#245bdb">v-else-if</font>

## 4.template上的v-if

## 5.<font color="#245bdb">v-show</font>

## 6.v-if和v-show


# <font color="#c0504d">07.列表渲染</font>


## 1.<font color="#245bdb">v-for</font>


>案例

```html
<script lang="ts" setup>
  import { ref, onMounted } from "vue";
  import axios from "../api/request";

  interface Student {
    id: number,
    name: string,
    sex: string,
    age: number
  }

  interface Result<T> {
    data: T[],
    message?: string, // 可选属性
    code: number
  }

  // students类型是Student[]
  const students = ref<Student[]>([]);

  async function getStudents() {
    // resp.data类型是Result<Student>
    const resp = await axios.get<Result<Student>>("/api/students");
    students.value = resp.data.data;
  }

  onMounted(() => getStudents());
  
</script>

<template>
  <div class="outer">
    <div class="title">学生列表</div>
    <div class="thead">
      <div class="row bold">
        <div class="col">编号</div>
        <div class="col">姓名</div>
        <div class="col">性别</div>
        <div class="col">年龄</div>
      </div>
    </div>
    <div class="tbody">
      <div v-if="students.length === 0">暂无数据</div>
      <template v-else>
        <div class="row" v-for="s of students" :key="s.id">
          <div class="col">{{ s.id }}</div>
          <div class="col">{{ s.name }}</div>
          <div class="col">{{ s.sex }}</div>
          <div class="col">{{ s.age }}</div>
        </div>
      </template>
    </div>
  </div>
</template>
```

# <font color="#c0504d">08.事件处理</font>

## 1.监听事件 <font color="#245bdb">v-on</font>

# <font color="#c0504d">09.表单绑定</font>

## 1.表单输入绑定 <font color="#245bdb">v-model</font>


# <font color="#c0504d">10.生命周期</font>

组合式API的生命周期钩子函数共有4个阶段



# <font color="#c0504d">11.侦听器</font>

计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改DOM，或是根据异步操作的结果去修改另一处的状态。

在组合式API中，我们可以使用<font color="#c0504d">watch</font>函数在每次响应式状态发生变化时触发回调函数：

* 第1个参数是被监听的一个或多个响应式数据，该参数有三种形式：
	1. 一个reactive对象或者ref对象。
	2. 返回reactive对象种基础类型属性的函数。
	3. 包含任意多个reactive对象、ref对象或函数的数组。
* 第2个参数是监听回调函数，该回调函数可接收两个参数，具体如下：
	1. 一个新值或包含多个新值的数组。
	2. 一个旧值或包含多个旧值的数组。
* 第3个参数是可选的配置对象，包含是否立即执行的immediate和是否深度监听的deep。

```
```


# 12.模板引用

TODO
# 13.组件基础


## 定义和使用组件


>局部注册与全局注册

[官方文档-组件注册](https://cn.vuejs.org/guide/components/registration.html)

* 局部注册
* 全局注册：全局注册组件后，会使该组件在当前应用中的任何组件上都可以使用，而不需要额外再导入。

>局部注册与全局注册 - 区别

全局注册虽然很方便，但有以下几个问题：

1. 全局注册，但并<font color="#c0504d">没有被使用的组件无法在生产打包时被自动移除</font>。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的JS文件中。
2. 全局注册在大型项目中使项目的<font color="#c0504d">依赖关系变得不那么明确</font>。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。

相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对更加友好。

