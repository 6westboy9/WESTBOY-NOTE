# 1.对象的原型理解

对象的原型
函数的原型
函数也是一个对象

## 1.什么是原型

![[Pasted image 20250308141700.png|800]]

>构造函数对象的`prototype`显示原型属性 ➡️ 构造函数的原型对象
>构造函数创建的对象的`_proto_`隐式原型属性 ➡️ 构造函数的原型对象

## 2.原型有什么用



## 3.重写原型

```js
function Foo() {  
}  
  
// 直接修改整个prototype对象  
Foo.prototype = {  
    name: "wang",  
    age: 18,  
    height: 180  
}  
  
var f1 = new Foo();  
  
console.log(f1.name, f1.age, f1.height);  
  
Object.defineProperty(Foo.prototype, "constructor", {  
    enumerable: false,  
    configurable: true,  
    writable: true,  
    value: Foo  
})  
  
console.log(f1.__proto__);
```

![[Pasted image 20250125191333.png|200]]

# 2.类和对象



# 3.原型链

我们知道，从一个对象上获取属性，如果在当前对象中没有获取到就会去它的原型上面获取：

![[Pasted image 20250127132611.png|600]]

## 1.Object原型对象

那么什么地方是原型链的尽头呢？比如第三个对象是否也是有原型`__proto__`属性呢？

```js
var obj = {
    name: "Foo",
    age: 4
};

obj.__proto__ = {};

obj.__proto__.__proto__ = {};

console.log(obj.address); // undefined

obj.__proto__.__proto__.__proto__ = {
    address: "上海市"
};

console.log(obj.address); // 上海市

console.log(obj.__proto__.__proto__.__proto__.__proto__); // [Object: null prototype] {}
```

* 我们会发现它打印的是`[Object: null prototype] {}`
* **事实上这个原型就是我们最顶层的原型了**

>从Object直接创建出来的对象的原型都是`[Object: null prototype] {}`，那么我们可能会问题：`[Object: null prototype] {}` 原型有什么特殊吗？

* 特殊一：该对象有原型属性，但是它的原型属性已经指向的是null，也就是已经是顶层原型了；
* 特殊二：该对象上有很多默认的属性和方法；

![[Pasted image 20250127132308.png|500]]

```js
var obj1 = {};
// 等价
var obj2 = new Object();
```

```js
var obj = {  
 name: "Foo",  
    age: 4  
}  
  
console.log(obj.__proto__ === Object.prototype); // true
```

## 2.Object原型对象所有属性

```js
// 打印Object的原型对象的所有属性
console.log(Object.getOwnPropertyDescriptors(Object.prototype));
```

```js
{
  constructor: {
    value: [Function: Object], // 指向的就是Object构造函数
    writable: true,
    enumerable: false,
    configurable: true
  },
  __defineGetter__: {
    value: [Function: __defineGetter__],
    writable: true,
    enumerable: false,
    configurable: true
  },
  __defineSetter__: {
    value: [Function: __defineSetter__],
    writable: true,
    enumerable: false,
    configurable: true
  },
  hasOwnProperty: {
    value: [Function: hasOwnProperty],
    writable: true,
    enumerable: false,
    configurable: true
  },
  __lookupGetter__: {
    value: [Function: __lookupGetter__],
    writable: true,
    enumerable: false,
    configurable: true
  },
  __lookupSetter__: {
    value: [Function: __lookupSetter__],
    writable: true,
    enumerable: false,
    configurable: true
  },
  isPrototypeOf: {
    value: [Function: isPrototypeOf],
    writable: true,
    enumerable: false,
    configurable: true
  },
  propertyIsEnumerable: {
    value: [Function: propertyIsEnumerable],
    writable: true,
    enumerable: false,
    configurable: true
  },
  toString: {
    value: [Function: toString],
    writable: true,
    enumerable: false,
    configurable: true
  },
  valueOf: {
    value: [Function: valueOf],
    writable: true,
    enumerable: false,
    configurable: true
  },
  ['__proto__']: {
    get: [Function: get __proto__],
    set: [Function: set __proto__],
    enumerable: false,
    configurable: true
  },
  toLocaleString: {
    value: [Function: toLocaleString],
    writable: true,
    enumerable: false,
    configurable: true
  }
}
```

## 3.原型链最顶层的原型对象


![[Pasted image 20250127183109.png|1000]]

原型链最顶层的原型对象就是Object原型对象。

# 4.继承的实现


## 1.原型链继承

**原理**：将子类的原型对象指向父类的实例。

```javascript
function Parent() {
  this.name = 'Parent';
}
Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child() {}
Child.prototype = new Parent(); // 继承父类

const child = new Child();
child.sayName(); // 输出 "Parent"
```

**缺点**：所有子类实例共享父类引用属性，无法向父类传参。

## 2.构造函数继承

**原理**：在子类构造函数中调用父类构造函数。

```javascript
function Parent(name) {  
    this.name = name;  
}  
  
function Child(name,age) {  
    Parent.call(this, name); // 继承属性
    // this.name = name; 等效于Parent.call(this, name);为了服用Parent属性而已  
    this.age = age;  
}  
  
const child1 = new Child('Child1',12);  
console.log(child1.name + ", " + child1.age); // 输出 "Child1, 12"  
const child2 = new Child('Child2',13);  
console.log(child2.name + ", " + child2.age); // 输出 "Child2, 13"
```

**缺点**：无法继承父类原型上的方法。

## 3.原型链+构造函数组合（常用）

**原理**：结合原型链和构造函数继承。

```javascript
function Parent(name) {
  this.name = name;
}

Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 继承属性（第二次调用Parent）
  this.age = age;
}

Child.prototype = new Parent(); // 继承方法（第一次调用Parent）
Child.prototype.constructor = Child; // 修正constructor

const child = new Child('Child', 5);
child.sayName(); // 输出 "Child"
```

**缺点**：
* <font color="#c0504d">父类构造函数被调用两次</font>
* <font color="#c0504d">子类原型中存在冗余属性</font>

![[Pasted image 20250308150338.png|600]]

## 4.寄生组合式继承（最优）

**原理**：使用`Object.create()`复制父类原型，避免调用父类构造函数。

```javascript
function inheritPrototype(Child, Parent) {
  const prototype = Object.create(Parent.prototype); // 复制父类原型
  prototype.constructor = Child; // 修正constructor
  Child.prototype = prototype;
}

function Parent(name) {
  this.name = name;
}

Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 继承属性
  this.age = age;
}

inheritPrototype(Child, Parent); // 继承方法

const child = new Child('Child', 5);
child.sayName(); // 输出 "Child"
```

**优点**：只调用一次父类构造函数，避免冗余属性，保持原型链完整。

## 5.ES6的class继承（推荐）

**原理**：使用`extends`和`super`语法糖，底层基于寄生组合式继承。

```javascript
class Parent {

  constructor(name) {
    this.name = name;
  }
  
  sayName() {
    console.log(this.name);
  }
  
}

class Child extends Parent {

  constructor(name, age) {
    super(name); // 调用父类构造函数
    this.age = age;
  }
  
  sayAge() {
    console.log(this.age);
  }
  
}

const child = new Child('Child', 5);
child.sayName(); // 输出 "Child"
child.sayAge(); // 输出 5
```

## 6.总结

- **原型链继承**：通过实例化父类实现，但存在引用共享问题。
- **构造函数继承**：通过调用父类构造函数解决属性隔离，但无法继承原型方法。
- **组合继承**：结合两者，但效率较低。
- **寄生组合式继承**：最优解，高效且原型链完整。
- **ES6的`class`**：语法简洁，底层使用寄生组合式继承，支持静态方法继承。

**最佳实践**：现代开发中优先使用ES6的`class`和`extends`，兼容性好且代码清晰。若需支持旧环境，可采用寄生组合式继承。


# 5.对象-函数-原型


![[Pasted image 20250308215630.png|1000]]

* `Function.prototype === Function.__proto__`

![[Pasted image 20250308220212.png|500]]

# 参考资料

* [JS原型链与继承别再被问倒了](https://juejin.cn/post/6844903475021627400)




