![[Pasted image 20250109123236.png|600]]

```js
function sum(x) {
    return function (y) {
        return function (z) {
            return x + y + z;
        };
    }
}

console.log(sum(10)(20)(30))

// 另外一种写法
const sum2 = x => y => z => {
    return x + y + z;
};

console.log(sum2(10)(20)(30))
```

### 基础柯里化示例

将一个接受多个参数的函数转换为一系列接受单个参数的函数。

```
const add = (a, b, c) => a + b + c;
const curriedAdd = curry(add);  // 将add转换为柯里化函数

// 一次传入所有参数
console.log(curriedAdd(1, 2, 3));

// 分步传入参数
const add1 = curriedAdd(1);
const add1and2 = add1(2);
const result = add1and2(3);
```

>输出结果： curriedAdd(1, 2, 3) = 6 curriedAdd(1)(2)(3) = 6

### 实际应用场景：日志记录器

使用柯里化创建特定级别的日志记录函数。

```
const log = curry((level, message, timestamp) => {
    return `[${level}] ${timestamp}: ${message}`;
});

const logError = log('ERROR');
const logErrorNow = logError('Server crashed');
```

>输出结果： logError('Server crashed')(2025-01-09T04:38:23.694Z) = [ERROR] 2025-01-09T04:38:23.694Z: Server crashed

柯里化的主要优点：

1. **参数复用**：可以固定某些参数，创建一个新的函数。
2. **延迟执行**：不需要立即传入所有参数，可以等到需要的时候再传入。
3. **代码复用**：通过固定部分参数，可以派生出新的功能函数。
4. **提高可读性**：将复杂的多参数函数分解成多个简单的单参数函数。

在现有代码中，`curry`函数的实现非常经典：

```js
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        }
        return function(...moreArgs) {
            return curried.apply(this, args.concat(moreArgs)); // concat将args和moreArgs数组拼接等效于: [...args,...moreArgs]
        }
    };
}
```

![[Pasted image 20250109183527.png|500]]

这个实现：

1. 检查传入的参数数量是否足够。
2. 如果参数足够，直接执行原函数。
3. 如果参数不够，返回一个新函数，等待接收更多参数。
