* https://juejin.cn/post/7070543044168122382
* https://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html


1. 函数在调用时，JavaScript会默认给this绑定一个值；
2. this的绑定和定义的位置（编写的位置）没有关系；
3. **this的绑定和调用方式以及调用的位置有关系**；
4. this是在运行时被绑定的；

# 绑定规则


## 1.默认绑定

独立函数调用，也就是在window下`函数名/变量名()`这样子去运行的，未加任何绑定或者`.XXX()`去进行运行的绑定。

>案例1

```js
function fun1() {
    console.log("fun1", this)
}

fun1() // 指向window
```

>案例2

```js
function fun2() {
    console.log("fun2", this)
}

function fun3() {
    console.log("fun3", this)
    fun2()
}

function fun4() {
    console.log("fun4", this)
    fun3()
}

fun4() // 指向window
```

>案例3

```js
let obj = {
    name: "哈哈哈",
    fun5: function () {
        console.log("fun5", this)
    }
}

// obj.fun5() // 这个有调用主体（他不是独立的，这个时候，它指向obj）
const fun6 = obj.fun5
fun6() // 指向window
```

>案例4

```js
function fun7() {
    console.log("fun7", this)
}

let obj2 = {
    name: "哈哈哈",
    fun: fun7
}

// obj.fun5() // 这个有调用主体（他不是独立的，这个时候，它指向obj）
const fun8 = obj2.fun
fun8() // 指向window
```

>案例5

```js
function fun9() {
    function bar() {
        console.log("fun9", this)
    }

    return bar
}

const fun10 = fun9()
fun10()
```

## 2.隐式绑定

通过某个对象，进行的函数调用。

>案例1

```js
function fun1(){
    console.log(this) 
}

let obj1 = {
    age:222,
    foo: fun1
}

obj1.foo() // obj1
let bar = obj1.foo
bar() // window
```

>案例2

```js
let obj2 = {
    age:22,
    foo: function () {
        console.log(this, this.age + obj2.age)
    }
}
obj2.foo() // { age: 22, foo: [Function: foo] } 44
```

>案例3

```js
let obj5 = {
    name: "obj3",
    foo: function () {
        console.log(this);
    }
}

let obj4 = {
    name: "obj4",
    // 对象中的属性，指向函数
    foo: obj5.foo
}

obj4.foo(); // { name: 'obj4', foo: [Function: foo] }
```

## 3.显示绑定

通过call、apply、bind改变函数体内的this指向。

### 1.call → 会立即执行

>案例1.单个参数

```js

let name = "你好";
let obj = {age: 22, name: "小明"};

function fun() {
    console.log(this, this.name);
}

fun.call(obj); // 立即执行 {age: 22, name: '小明'} '小明'
fun(); // Window ''
```

>案例2.多个参数 → **按顺序传递**

```js
let name = "你好";
let obj = {name: "小明"};

function fun(age, gender) {
    // 这个 是传入的
    this.age = age;
    this.gender = gender;
    console.log(this, this.name);
}

fun.call(obj, 222, "boy"); // {name: '小明', age: 222, gender: 'boy'} '小明'
```

### 2.apply → 会立即执行

>案例1.单个参数

```js
let name = "你好";
let obj = {age: 22, name: "小明"};

function fun() {
    console.log(this, this.name);
}

fun.apply(obj); // 立即执行 {age: 22, name: '小明'} '小明'
fun(); // Window ''
```

>案例2.多个参数 → **数组按顺序传递**

```js
let name = "你好";
let obj = {name: "小明"};

function fun(age, gender) {
    // 这个 是传入的
    this.age = age;
    this.gender = gender;
    console.log(this, this.name);
}

fun.apply(obj, [222, "boy"]); // {name: '小明', age: 222, gender: 'boy'} '小明'
```
### 3.bind → 不立即执行

>案例1.单个参数

```js
let name = "你好";
let obj = {age: 22, name: "小明"};
function fun(){
    console.log(this, this.name);
}

fun.bind(obj); // 不立即执行，bind返回的是一个函数，立即执行要加括号
fun.bind(obj)(); // {age: 22, name: '小明'} '小明' 
fun(); // Window ''
```

>案例2.多个参数 → **按顺序传递**

```js
let name = "你好";
let obj = {name: "小明"};

function fun(age, gender) {
    // 这个 是传入的
    this.age = age;
    this.gender = gender;
    console.log(this, this.name);
}

fun.bind(obj, 222, "boy")();
```

## 4.自己实现call/apply/bind方法


## 5.new绑定

```js
/**
 * new构造函数
 *
 * 1.this = 创建出来的对象
 * 2.这个绑定过程，就是new绑定
 * 3.添加属性的时候，也就是属性添加进 this = {} 中
 */
function Person(val1, val2) {
    this.val1 = val1;
    this.val2 = val2;
}

let p1 = new Person("呵呵", "哈哈哈");
console.log(p1.val1, p1.val2); // 呵呵 哈哈哈

let p2 = new Person("age", 25);
console.log(p2.val1, p2.val2); // age 25
```

## 6.绑定优先级

>new绑定 > 显示绑定 > 隐式绑定 > 默认绑定

>new绑定优先级高于bind（*new绑定和call、apply不能一块使用，但是bind可以*）

```js

```


```js
function fun(){
    console.log(this) 
}

let fn = fun.bind("哈哈哈");
fn();               // String {'哈哈哈'} → bind优先级高于 
let obj = new fn(); // fun{} → new绑定优先级高于bind
```

# 内置函数的绑定


## 1.setTimeout


## 2.元素中的this指向


## 3.数组方法的this指向


# 特殊情况


# 箭头函数

# 案例


```js
var helper = {
    name: '助手',
    tasks: ['任务1', '任务2', '任务3'],
    showTasks: function () {
        // this指向helper对象
        this.tasks.forEach(function (task) {
            console.log(this.name + '的' + task);
        });
    }
}

helper.showTasks();
```

```
undefined的任务1
undefined的任务2
undefined的任务3
```


