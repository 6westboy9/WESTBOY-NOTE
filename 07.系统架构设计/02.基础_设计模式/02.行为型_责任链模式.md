
# 资料

- [开源框架中的责任链模式实践](https://mp.weixin.qq.com/s/qJ2MvhLiWJ9uqINMYupnjA)

# 责任链定义


# 责任链实现

### 1.处理器自驱动

>1.定义抽象类

```java
public abstract class AbstractHandler {
    protected Handler next = null;

    // 绑定处理器
    public void setSuccessor(Handler next) {
        this.next = next;
    }

    // 处理器执行操作并驱动下一个处理器
    public abstract void handle();
}
```

> 2.定义处理器

```java
public class HandlerA extends AbstractHandler {
    @Override
    public void handle() {
        // do something
        if (next != null) {
            next.handle();
        }
    }
}

public class HandlerB extends AbstractHandler {
    @Override
    public void handle() {
        // do something
        if (next != null) {
            next.handle();
        }
    }
}

```

>3.构建责任链并添加处理器

```java
public class HandlerChain {

    // 通过链表的形式保存责任链
    private AbstractHandler head = null;
    private AbstractHandler tail = null;

    public void addHandler(AbstractHandler handler) {
        handler.setSuccessor(null);

        if (head == null) {
            head = handler;
            tail = handler;
            return;
        }

        tail.setSuccessor(handler);
        tail = handler;
    }

    public void handle() {
        if (head != null) {
            head.handle();
        }
    }
}
```

>4.整体构建责任链添加处理器并进行驱动

```java
public class Application {
    public static void main(String[] args) {
        // 构建责任链并添加处理器
        HandlerChain chain = new HandlerChain();
        chain.addHandler(new HandlerA());
        chain.addHandler(new HandlerB());
        // 责任链负责触发
        chain.handle();
    }
}
```

说明：
- 责任链上的每个处理器对象维护下一个处理器对象，<font color="#f79646">整个责任链的驱动由每个处理器对象自行驱动</font>。
- 每个处理器对象中包含下一个处理器对象`next`的变量，通过链表形式维护责任链的关系。

### 2.责任链驱动

>1.定义抽象接口

```java
public interface IHandler {
    void doSomething();
}
```

>2.定义处理器

```java
public class HandlerA implements IHandler {
    @Override
    public void doSomething() {
        // do something
    }
}

public class HandlerB implements IHandler {
    @Override
    public void doSomething() {
        // do something
    }
}
```

>3.构建责任链并添加处理器

```java
public class HandlerChain {  

    // 通过数组的形式保存处理器  
    private List<IHandler> handlers = new ArrayList<>();  
  
    public void addHandler(IHandler handler) {  
        handlers.add(handler);  
    }  
  
    // 由责任链负责遍历所有的处理器并进行调用  
    public void handle() {  
        for (IHandler handler : handlers) {  
            handler.handle();  
        }  
    }  
}  
```

>4.整体构建责任链添加处理器并进行驱动

```java
public class Application {  
    public static void main(String[] args) {  
        HandlerChain chain = new HandlerChain();  
        chain.addHandler(new HandlerA());  
        chain.addHandler(new HandlerB());  
        chain.handle();  
    }  
}
```

说明：
- 责任链对象本身以数组的形式维护处理器对象，即上述代码中的`HandlerChain#handlers`。
- 责任链的处理器的执行由责任链对象循环调用处理器对象驱动，即上述代码中的`HandlerChain#handle`方法。

# 开源框架中责任链应用


