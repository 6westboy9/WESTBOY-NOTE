# 整体流程


![[Pasted image 20231030102350.png|700]]


# 实现


## 代码比较


### 方案比较


|技术方案   |区别   |实现复杂度   |
|---|---|---|
|JGit|- 源码文件比较<br>- 比对的代码必须为Git管理<br>- 借助JGit直接基于源码文件比较差异内容，但是对于差异内容还需要进一步解析，才能得到变动代码块所影响的方法<br>- 只是新增空格时会有差异|较低|
|ASM|- 字节码层面直接比较（没有源码时唯一可选方式）<br>- 无需Git管理<br>- 只是新增空格时会无差异|较高|


### 比较结果


目前代码比较结果如下所示：

```
>>> data-sync-controller-2.1.1.jar
>>> └── [删除] com/lachesis/datasync/controller/JmsModelController.class
>>>   ├── [删除] <init>()V
>>>   ├── [删除] manualProcess(Ljava/lang/String;)Ljava/lang/String;
>>>   ├── [删除] test(Ljava/lang/String;)Ljava/lang/String;
>>>   └── [删除] <clinit>()V
>>> data-sync-service-2.1.1.jar
>>> ├── [修改] com/lachesis/datasync/common/RedisConstants.class
>>> │ ├── [修改] <init>()V
>>> │ └── [新增] mockAddMethod()V
>>> ├── [修改] com/lachesis/datasync/processer/impl/SyncDataProcesser.class
>>> │ ├── [修改] convertResponseToResults(Lcom/lachesis/datasync/common/MappingConstants;Lcom/lachesis/windranger/sync/model/SysTableSyncConfigExt;Ljava/lang/String;)Lcom/lachesis/datasync/vo/Result;
>>> │ ├── [删除] convertResponseByXml(Lcom/lachesis/datasync/common/MappingConstants;Lcom/lachesis/windranger/sync/model/SysTableSyncConfigExt;Ljava/lang/String;)Lcom/lachesis/datasync/vo/Result;
>>> │ ├── [删除] decodeIfNecessary(Lcom/lachesis/datasync/common/MappingConstants;Lcom/lachesis/windranger/sync/model/SysTableSyncConfigExt;Ljava/lang/String;)Ljava/lang/String;
>>> │ ├── [删除] convertByTableNode(Lcom/lachesis/windranger/sync/model/SysTableSyncConfigExt;Ljava/lang/String;)Ljava/util/List;
>>> │ ├── [删除] getJsonObjectByResponse(Lcom/lachesis/windranger/sync/model/SysTableSyncConfigExt;Ljava/lang/String;)Lcom/alibaba/fastjson/JSONObject;
>>> │ └── [新增] mockAddMethod()V
>>> └── [新增] com/lachesis/datasync/common/HelloWord.class
>>>   ├── [新增] <init>()V
>>>   └── [新增] main([Ljava/lang/String;)V
```

粒度到方法级别，事实上，业界目前的作业也都是方法级别。期望的是通过<font color="#f79646">比较结果</font>+<font color="#f79646">动态链路</font>+<font color="#f79646">用例知识库</font>=<font color="#f79646">用例推荐</font>，这是如何做到呢？
 
当前猜想
 
* 根据比较结果，在动态链路记录中去匹配相同路径（类路径#方法）的记录（应该就是所谓的TraceNode）。
* 然后根据该记录再去找接口级别的（类路径#方法）记录。
* 再根据接口级别的记录，从<font color="#f79646">用例知识库</font>中找用例。

## 代码覆盖动态追踪


我们先看个示例代码：

```java
public class Test {  
  
    public void test_0() {  
        test_01();  
        test_02();  
    }  
  
    private void test_01() {  
    }  
  
    private void test_02() {  
        test_021();  
        test_022();  
        test_023();  
    }  
  
    private void test_021() {  
        test_0211();  
    }  
  
    private void test_0211() {  
        test_02111();  
    }  
  
    private void test_02111() {  
    }  
  
    private void test_022() {  
        test_0221();  
        test_0222();  
    }  
  
    private void test_0222() {  
    }  
  
    private void test_0221() {  
    }  
  
    private void test_023() {  
    }
}
```

上述代码是一个非常简单的示例，执行的链路大致如下：

```
┌ org.westboy.temp.Test.test_0
│ ┌ org.westboy.temp.Test.test_01
│ └ org.westboy.temp.Test.test_01
│ ┌ org.westboy.temp.Test.test_02
│ │ ┌ org.westboy.temp.Test.test_021
│ │ │ ┌ org.westboy.temp.Test.test_0211
│ │ │ | ┌ org.westboy.temp.Test.test_02111
│ │	│ │ └ org.westboy.temp.Test.test_02111
│ │ │ └ org.westboy.temp.Test.test_0211
│ │ └ org.westboy.temp.Test.test_021
│ │ ┌ org.westboy.temp.Test.test_022
│ │ │ ┌ org.westboy.temp.Test.test_0221
│ │ │ └ org.westboy.temp.Test.test_0221
│ │ │ ┌ org.westboy.temp.Test.test_0222
│ │ │ └ org.westboy.temp.Test.test_0222
│ │ └ org.westboy.temp.Test.test_022
│ │ ┌ org.westboy.temp.Test.test_023
│ │ └ org.westboy.temp.Test.test_023
│ └ org.westboy.temp.Test.test_02
└ org.westboy.temp.Test.test_0
```

下图所示描述了上述方法`test_0`方法的调用链路：

![[Pasted image 20231030122133.png|500]]

在此涉及到JVM中重要的概念：<font color="#f79646">局部变量表</font>和<font color="#f79646">操作数栈</font>。

### 实现方案

==会话机制==


![[Pasted image 20231030122039.png|500]]


待完善点：

* 多线程
* 进入方法
* 退出方法
	* 正常退出
	* 异常退出



==数据采集==


* 采集数据
	* 实时上传
	* 上传至采集服务器


### 需要考虑的细节


一个用例会涉及多个接口，可能这些接口都是一个应用，也可能是多个应用。

基于用例

* 关联方法
* 调用链路
* 覆盖率信息

用例与链路关联，即需要维护用例库，或者在用例调用接口的时候，传递用例唯一ID，这样用例才能与链路关联。

### 数据结构设计


测试用例

* 用例编号
* 用例名称
* 用例权重（测试更应关注高权重用例）
* 用例标签（对用例进行打标）

### 追踪结果

当前生成的代码覆盖动态追踪链路（需要完善）：

```
0 [ERROR]coderead.test.Test.main()[] time:0: size:1:
0.1 coderead/test/Test.<init> ()V()[,12L] time:72166: size:1:
0.2 coderead/test/Test.A (Ljava/lang/String;)V()[,15L,18L] time:162400: size:1:
0.2.1 coderead/test/Test.B ()V()[,26L] time:145778: size:1:
0.2.1.1 coderead/test/Test.C ()V()[,30L] time:135429: size:1:
```

需要思考的问题：
* 这些链路信息是不是需要持久化存储？数据结构如何设计？
* 如何跟上面用例推荐整合？

### 思考


# 难点克服


* JavaAgent类加载的问题
* 分布式链路追踪
	* SkyWalking
	* Pinpoint
* 本地方法链路追踪

## 测试覆盖率


需要支持差异代码的测试覆盖率，因为差异代码比较为方法级别，所以<font color="#f79646">差异代码的测试覆盖率</font>指的就是<font color="#f79646">差异方法代码块的测试覆盖率</font>。

差异覆盖率报告只会针对差异代码部分。

>个人觉得与其说是增量覆盖率报告，不如说是差异覆盖率。


# 借鉴SkyWalking实现













