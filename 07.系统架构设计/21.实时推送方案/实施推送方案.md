原文：[求求别卷了!这7个实时推送方案,让系统流畅到想喊救命](https://articles.zsxq.com/id_gqrpblwl7e8k.html?wxauth_new=true&wxauth_from=nomal)

# 1.轮询（Polling）：最朴实的 "勤务员"

要说实时推送方案里最基础、最朴实的，那非轮询莫属了。轮询就像是一个非常勤奋的 "勤务员"，客户端每隔一段时间就向服务器发送请求，询问是否有新的数据需要推送。比如说，客户端设置每 5 秒钟向服务器发送一次请求，服务器收到请求后，检查是否有新的消息，如果有就返回给客户端，没有就返回一个空的响应。

## 1.短轮询

短轮询是轮询中最直接的方式。客户端每次发送请求后，不管有没有数据，都很快收到服务器的响应。举个简单的例子，就像你在等快递，每隔几分钟就打电话给快递站问 "我的快递到了吗"，快递站不管有没有到，都会马上回复你。这种方式的优点很明显，实现简单，兼容性非常好，几乎所有的客户端和服务器都支持。而且对于一些简单的实时性要求不高的场景，比如一些不太重要的通知查询，短轮询还是能满足需求的。但是它的缺点也不少。首先，它太 "勤劳" 了，不管有没有新数据，客户端都要定时发送请求，这就会导致服务器在大部分时间里处理的都是无效请求，浪费了大量的资源。就好比你频繁打电话问快递，快递站的工作人员大部分时间都在处理你的无效询问，影响了工作效率。而且客户端的实时性取决于轮询的间隔时间，如果间隔时间设置得太短，会增加网络开销和服务器压力；如果设置得太长，又会导致客户端获取新数据不及时，实时性差。

## 2.长轮询

为了弥补短轮询的不足，长轮询应运而生。长轮询中，客户端向服务器发送请求后，服务器如果没有新数据，不会立即返回响应，而是保持这个连接一段时间，直到有新数据产生或者连接超时才返回。这就好像你打电话给快递站，说 "等我的快递到了就马上告诉我"，快递站收到你的请求后，一直等着快递到达，到达后就立即告诉你，要是等了很久还没到，就告诉你暂时没到。长轮询的优点是在没有新数据时，不会像短轮询那样频繁地发送无效请求，减少了服务器的压力和网络开销，同时又能在一定程度上保证实时性，比短轮询的实时性要好一些。比如在一些实时聊天场景中，用户发送消息后，对方希望能尽快收到，长轮询就可以在一定时间内等待新消息，而不是频繁请求。不过它也有缺点。服务器需要维护这些长时间的连接，这对服务器的并发处理能力有一定的要求。而且当同时有大量客户端进行长轮询时，服务器可能会因为维护过多的连接而不堪重负。另外，长轮询仍然是基于请求 - 响应模式，每次请求都需要建立 HTTP 连接，在高并发场景下，连接的建立和关闭也会带来一定的开销。

# 2.WebSocket：全双工通信的 "实时高手"

随着互联网的发展，对实时性要求越来越高，轮询这种基于请求 - 响应的模式已经难以满足需求，于是 WebSocket 出现了。WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，它允许服务器和客户端之间进行实时、双向的通信。简单来说，就是客户端和服务器建立连接后，就像打通了一条双向的通道，双方可以随时主动向对方发送数据，不再像 HTTP 那样只能客户端发起请求，服务器被动响应。

## 工作原理

WebSocket 的握手过程是基于 HTTP 的，客户端首先发送一个 HTTP 请求到服务器，请求升级协议到 WebSocket。服务器收到请求后，如果支持 WebSocket 协议，就会返回一个升级协议的响应，完成握手，之后双方就可以通过这个 TCP 连接进行全双工通信了。在通信过程中，数据可以以帧的形式发送，支持文本和二进制数据。

## 优点

1. **实时性强** ：由于是全双工通信，服务器可以主动向客户端发送数据，不需要客户端频繁请求，能够实现真正的实时推送。比如在在线聊天应用中，对方发送消息后，客户端可以立即收到，几乎没有延迟。
2. **减少开销** ：WebSocket 建立连接后，后续的数据传输不需要像 HTTP 那样每次都携带大量的头部信息，减少了网络开销，提高了传输效率。
3. **支持二进制数据** ：可以方便地传输二进制数据，比如图片、视频等，这对于一些需要实时传输多媒体数据的场景非常有用。
    

## 缺点

1. **兼容性问题** ：虽然现在主流的浏览器都支持 WebSocket，但在一些老旧的浏览器中可能支持不够好，需要做兼容性处理。
2. **部署成本** ：WebSocket 需要服务器支持相应的协议，对于一些现有的 HTTP 服务器，可能需要进行升级或改造，增加了部署成本。
3. **安全性** ：WebSocket 连接一旦建立，就可以双向通信，需要注意防止恶意连接和数据攻击，需要在应用层做好安全措施。
    

# 3.SSE：服务器到客户端的 "单向高速路"

> Server - Sent Events

SSE 是一种允许服务器主动向客户端发送数据的技术，它建立在 HTTP 协议之上，是一种单向的通信方式，只能服务器向客户端发送数据，客户端不能主动向服务器发送数据。它就像是一条从服务器到客户端的 "单向高速路"，服务器可以源源不断地向客户端推送数据。

## 工作原理

客户端通过发送一个 HTTP 请求到服务器，请求建立 SSE 连接。服务器收到请求后，保持这个连接打开，然后可以随时向客户端发送数据，数据格式为文本，以 "event stream" 的形式传输。客户端接收到数据后，会触发相应的事件进行处理。

## 优点

1. **简单易用** ：基于 HTTP 协议，实现相对简单，客户端不需要像 WebSocket 那样处理复杂的连接和消息格式。
2. **适合单向推送** ：对于一些只需要服务器向客户端推送数据的场景，比如实时新闻更新、股票行情推送等，SSE 是一个很好的选择，不需要双向通信，减少了不必要的复杂性。
3. **自动重连** ：浏览器原生支持 SSE 的自动重连机制，当连接断开时，会自动尝试重新建立连接，提高了连接的可靠性。

## 缺点

1. **单向通信** ：只能服务器向客户端发送数据，不支持客户端向服务器发送数据，适用场景有限。
2. **兼容性** ：虽然主流浏览器支持 SSE，但在一些低版本的浏览器中可能存在兼容性问题，需要进行检测和处理。
3. **性能限制** ：基于 HTTP 长连接，在高并发场景下，服务器需要维护大量的连接，对服务器的性能有一定的影响。
    
# 4.消息队列（Message Queue）：异步解耦的 "中间桥梁"

在分布式系统中，消息队列是一个非常重要的组件，它在实时推送中也发挥着重要的作用。消息队列就像是一个 "中间桥梁"，连接着生产者和消费者，生产者将需要推送的消息发送到消息队列中，消费者从消息队列中获取消息并进行处理。

## 常见消息队列

1. **Kafka** ：Kafka 是一个高吞吐量、分布式的消息队列，适合处理大规模的实时数据。它具有良好的扩展性和容错性，支持消息的持久化存储，能够保证消息不丢失。Kafka 的应用场景非常广泛，比如日志收集、实时数据分析、实时推送等。在实时推送中，当有大量的推送任务时，Kafka 可以将消息暂存起来，消费者可以根据自己的处理能力逐步获取消息进行推送，避免了服务器的压力过大。
2. **RabbitMQ** ：RabbitMQ 是一个基于 AMQP 协议的消息队列，它具有轻量级、灵活、易于部署等特点，支持多种编程语言和协议。RabbitMQ 提供了丰富的消息路由机制，可以根据不同的需求将消息路由到不同的消费者，适合中小型系统的实时推送需求。
3. **RocketMQ** ：RocketMQ 是阿里巴巴开源的消息队列，具有高可用性、高吞吐量、低延迟等特点，支持分布式事务和顺序消息。它在电商等领域有广泛的应用，能够满足复杂的实时推送场景的需求。

## 优点

1. **异步解耦** ：生产者和消费者不需要直接交互，通过消息队列进行解耦，生产者只需要将消息发送到队列中，不需要关心消费者如何处理；消费者也不需要关心消息从哪里来，只需要从队列中获取消息进行处理。这样可以提高系统的灵活性和可扩展性，当生产者或消费者发生变化时，不会影响到对方。
2. **削峰填谷** ：在高并发场景下，消息队列可以将大量的消息暂存起来，消费者可以按照自己的处理能力逐步处理，避免了服务器因瞬间高并发而崩溃，起到了削峰填谷的作用。比如在电商大促时，大量的推送请求可以先进入消息队列，然后消费者慢慢处理，保证了系统的稳定性。
3. **保证消息可靠传输** ：大多数消息队列都支持消息的持久化存储和确认机制，能够保证消息不丢失，确保推送任务的可靠性。
 
## 缺点

1. **引入复杂性** ：使用消息队列需要考虑队列的管理、消息的路由、分布式事务等问题，增加了系统的复杂性，需要开发者具备一定的分布式系统知识。
2. **延迟问题** ：消息在队列中可能会有一定的延迟，尤其是在消息堆积的情况下，延迟会更明显，这对于一些对实时性要求极高的场景可能不太适用。
3. **一致性问题** ：在分布式系统中，消息队列的使用可能会带来数据一致性问题，需要采取相应的措施来保证数据的一致性。

# 5.HTTP/2 Server Push：HTTP 协议的 "新技能"

随着 HTTP/2 协议的普及，Server Push 成为了一个备受关注的功能。HTTP/2 Server Push 允许服务器在响应客户端请求时，主动将客户端可能需要的资源（比如图片、样式表、脚本等）推送给客户端，而不需要客户端再次发送请求。虽然它主要是用于资源推送，但在一些实时推送场景中也可以发挥作用。

## 工作原理

当客户端向服务器发送一个请求获取某个页面时，服务器在处理这个请求的过程中，知道客户端接下来可能需要哪些资源（比如页面上的图片、CSS 文件、JS 文件等），于是在返回页面响应的同时，主动将这些资源推送给客户端。客户端收到这些推送的资源后，可以直接使用，不需要再发送请求获取，减少了网络请求的次数。

## 优点

1. **减少延迟** ：提前推送客户端可能需要的资源，减少了客户端再次发送请求的延迟，提高了页面的加载速度，对于实时性要求较高的页面推送有一定的帮助。
2. **基于 HTTP/2** ：利用 HTTP/2 的多路复用和二进制分帧等特性，提高了资源传输的效率，降低了网络开销。
    
## 缺点

1. **适用场景有限** ：主要适用于页面资源的推送，对于一般的实时数据推送，比如消息通知等，适用场景相对有限。
2. **服务器判断困难** ：服务器需要准确判断客户端需要哪些资源进行推送，如果推送了客户端不需要的资源，反而会浪费带宽和服务器资源。
3. **兼容性** ：需要客户端和服务器都支持 HTTP/2 协议，对于一些不支持 HTTP/2 的老旧设备和服务器，无法使用该功能。
    
# 6.gRPC：高性能的 "远程调用专家"

gRPC 是由 Google 开发的一款高性能、开源的远程过程调用（RPC）框架，它基于 HTTP/2 协议，支持多种编程语言，在分布式系统中得到了广泛的应用。在实时推送场景中，gRPC 可以用于服务器之间的通信，也可以用于服务器与客户端之间的实时交互。

## 工作原理

gRPC 使用 Protocol Buffers 作为接口定义语言和数据序列化格式，客户端和服务器根据定义好的接口进行通信。gRPC 支持四种服务类型：一元 RPC（客户端发送一个请求，服务器返回一个响应）、服务器流式 RPC（客户端发送一个请求，服务器返回一个流式响应）、客户端流式 RPC（客户端发送一个流式请求，服务器返回一个响应）、双向流式 RPC（客户端和服务器都可以发送流式的请求和响应）。在实时推送中，可以使用服务器流式 RPC 或双向流式 RPC，实现服务器向客户端的实时数据推送。

## 优点

1. **高性能** ：基于 HTTP/2 协议，支持多路复用和二进制传输，提高了传输效率，降低了延迟，适合对性能要求较高的实时推送场景。
2. **跨语言支持** ：支持多种编程语言，方便不同语言开发的客户端和服务器进行通信，在分布式微服务架构中非常有用。
3. **强类型定义** ：使用 Protocol Buffers 进行接口定义，具有强类型检查，减少了接口调用的错误，提高了系统的可靠性。

## 缺点

1. **学习成本高** ：需要学习 Protocol Buffers 和 gRPC 的相关知识，对于初学者来说，学习成本较高。
2. **依赖 HTTP/2** ：需要客户端和服务器都支持 HTTP/2 协议，在一些不支持 HTTP/2 的环境中，无法发挥其优势。
3. **复杂性** ：相对于一些简单的实时推送方案，gRPC 的实现和部署相对复杂，需要处理服务发现、负载均衡等问题。

# 7.WebRTC：实时通信的 "全能选手"

WebRTC（Web Real - Time Communication）是一个开源项目，旨在通过浏览器实现实时通信，支持视频通话、语音通话、数据传输等功能。它在实时推送场景中，尤其是需要实时交互和多媒体传输的场景，具有很大的优势。

## 工作原理

WebRTC 允许浏览器之间直接建立点对点（P2P）的连接，不需要通过服务器进行中转（当然，在需要穿越防火墙等情况下，可能需要服务器作为中转）。客户端之间可以直接传输数据，实现低延迟的实时通信。它提供了一系列的 API，包括媒体捕获、视频编码解码、网络传输等，方便开发者实现实时通信功能。

## 优点

1. **低延迟** ：支持点对点通信，减少了服务器中转带来的延迟，能够实现几乎实时的数据传输，适合对延迟要求极高的场景，比如实时游戏、在线教育直播中的互动推送等。
2. **多媒体支持** ：原生支持视频、音频等多媒体数据的传输，不需要额外的插件或组件，方便实现富媒体的实时推送。
3. **浏览器原生支持** ：主流浏览器都内置了 WebRTC 支持，客户端无需安装额外的软件，降低了使用门槛。
    

## 缺点

1. **复杂性** ：WebRTC 的实现涉及到网络穿透、媒体编解码、流控制等复杂的技术，开发难度较大，需要开发者具备较高的技术水平。
2. **防火墙和 NAT 穿透问题** ：在复杂的网络环境中，实现点对点的连接可能会遇到防火墙和 NAT 穿透的问题，需要借助服务器进行中转，增加了系统的复杂性。
3. **服务器角色** ：虽然支持点对点通信，但在一些场景下仍需要服务器进行信令交换和管理，增加了服务器的负担。
    

# 总结：适合自己的才是最好的

说了这么多实时推送方案，每个方案都有自己的优缺点和适用场景。轮询虽然简单，但实时性和效率不高，适合一些简单的小场景；WebSocket 实时性强，支持双向通信，适合对实时性要求高的复杂场景；SSE 适合单向的实时数据推送；消息队列能够实现异步解耦和削峰填谷，适合分布式系统中的大规模推送；HTTP/2 Server Push 主要用于页面资源的推送；gRPC 适合高性能的远程调用和实时交互；WebRTC 则在实时多媒体通信和低延迟场景中表现出色。在实际开发中，不要盲目地追求 "卷"，觉得别人用了高大上的方案自己也一定要用。而是要根据自己的系统需求、实时性要求、并发量、复杂度等因素来选择合适的方案。有时候，简单的方案反而更稳定、更高效。比如，如果你的系统只是需要简单的实时通知，实时性要求不是特别高，那么长轮询可能就足够了，没必要去引入复杂的 WebSocket 或消息队列。如果是一个高并发的分布式系统，需要处理大量的实时推送任务，那么消息队列结合 WebSocket 可能是一个不错的选择。最重要的是，无论选择哪种方案，都要注重系统的性能和稳定性，不要为了追求功能而牺牲用户体验。希望这 7 个方案能够帮助你找到最适合自己系统的实时推送方式，让你的系统流畅到让用户想喊救命，再也不用在实时推送的 "卷" 中挣扎啦！
