# 总览

Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。

![[Pasted image 20240613185104.png|800]]

顶层接口是Executor，提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器Executor中，由Executor框架完成线程的调配和任务的执行部分。

![[Pasted image 20240613185133.png|500]]

ExecutorService接口增加了一些能力：

- 扩充执行任务的能力，补充可以为一个或一批异步任务生成`Future`的方法。
- 提供了管控线程池的方法，比如停止线程池的运行。

![[Pasted image 20240613185150.png|500]]

AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。

![[Pasted image 20240613185210.png|500]]

最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。

# 生命周期

线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态<font color="#f79646">runState</font>和线程数量<font color="#f79646">workerCount</font>。在具体实现中，线程池将运行状态、线程数量两个关键参数的维护放在了一起，如下代码所示：

```java
// 线程池的运行状态和线程池中有效线程的数量进行控制的一个字段
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// 线程池状态
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;

// 获取生命周期状态
private static int runStateOf(int c)     { return c & ~CAPACITY; }
// 计算当前线程数量
private static int workerCountOf(int c)  { return c & CAPACITY; }
// 通过状态和线程数生成ctl
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

变量<font color="#f79646">ctl</font>它同时包含两部分的信息：

1. 线程池的运行状态runState <font color="#c0504d">高3位</font>
2. 线程池内有效线程的数量workerCount <font color="#c0504d">低29位</font>

两个变量之间互不干扰，用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。

ThreadPoolExecutor的五种运行状态：

- <font color="#f79646">RUNNING</font>（对应值为-1）：能接收新提交的任务，并且也能处理阻塞队列中的任务。
- <font color="#f79646">SHOTDOWN</font>（对应值为0）：关闭状态，不再接收新提交的任务，但却可以继续处理阻塞队列中已保存的任务。
- <font color="#f79646">STOP</font>（对应值为1）：不能接收新任务，也不能处理队列中的任务，会中断正在处理任务的线程。
- <font color="#f79646">TIDYING</font>（对应值为2）：所有的任务都已终止了，有效线程数workerCount为0。
- <font color="#f79646">TERMINATED</font>（对应值为3）：执行了terminated方法，执行完后进入该状态。

![[Pasted image 20240613182352.png|600]]

>纠正：未0 => 为0

# 执行机制

>ThreadPoolExecutor运行机制

![[Pasted image 20240613185230.png|1100]]

## 流程

>准确的说这里的流程指<font color="#f79646">ThreadPoolExecutor#execute方法的执行流程</font>

- 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要<font color="#f79646">保证在RUNNING的状态</font>下执行任务。
- 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。
- 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
- 如果workerCount >= corePoolSize && workerCount <= maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
- 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。

![[Pasted image 20240717095615.png|500]]

>[!summary] 思考
>其实可以看出来，这种策略，并不是公平的，后提交的任务，有可能会被先执行（阻塞队列已满+线程数小于最大线程数时）
## 拒绝策略

任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到`maximumPoolSize`时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。

拒绝策略是一个接口，其设计如下：

```java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略。

![[Pasted image 20240613180917.png|500]]

```java
// 默认拒绝策略
public static class AbortPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString());
    }
}

// 在线程池没关闭的情况下，由调用者线程去处理任务，反之直接丢弃
public static class CallerRunsPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            r.run();
        }
    }
}

// 丢弃队列中最老的任务，然后重新提交被拒绝的任务
public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll();
            e.execute(r);
        }
    }
}

// 丢弃任务，不抛出异常
public static class DiscardPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    }
}
```

# 线程池关闭



# 自定义线程池

- 原生线程池提供的执行流程，主要用在<font color="#f79646">CPU密集型</font>场景下。
- 像Tomcat、Dubbo这类框架，他们内部的线程池主要用来处理网络IO任务的，所以他们都对JUC线程池的执行流程进行了调整来支持<font color="#f79646">IO密集型</font>场景使用。

>Tomcat线程池实现


>Dubbo线程池实现


# 线程池监控


# 动态线程池

* [DynamicTp](https://www.yuque.com/westboy/xk1bf0/memo91vddvewid3e)
	* [GitHub - dromara/dynamic-tp](https://github.com/dromara/dynamic-tp)
	* [官网 | DynamicTp](https://dynamictp.cn/)
* Hippo4j
	* [GitHub - opengoofy/hippo4j](https://github.com/opengoofy/hippo4j)
	* [官网 | Hippo4j](https://hippo4j.cn/)

* [Hippo4j和DynamicTp动态线程池介绍和使用中遇到的坑-CSDN博客](https://blog.csdn.net/qq_34905631/article/details/129694158)

# 常见问题


## 1.任务执行异常丢失

[ThreadPoolExecutor是如何处理任务的异常情况_明月的博客](https://blog.csdn.net/hl_java/article/details/106537023)


## 2.取消任务


[线程池停止超时任务](https://blog.csdn.net/zhangdx001/article/details/106928214)

`cancel(false)`与`cancel(true)`的区别：

* `cancel(false)`只取消已经提交但还没有被运行的任务（即任务就不会被安排运行）
* `cancel(true)`会取消所有已经提交的任务，包括正在等待的和正在运行的任务

## 3.TreadLocal在线程池下失效

https://github.com/alibaba/transmittable-thread-local

## 4.常用execute方法与submit方法的区别

[ThreadPoolExecutor是如何处理任务的异常情况_明月的博客](https://blog.csdn.net/hl_java/article/details/106537023)

| 方法      | 定义接口类           | 实现类                     |                                        |
| ------- | --------------- | ----------------------- | -------------------------------------- |
| execute | Executor        | ThreadPoolExecutor      | 无返回值                                   |
| submit  | ExecutorService | AbstractExecutorService | 有返回值，返回一个FutureTask对象，可以调用get方法阻塞获取返回值 |

><font color="#f79646">FutureTask的实现原理</font>

![[Pasted image 20240515094342.png|1200]]



