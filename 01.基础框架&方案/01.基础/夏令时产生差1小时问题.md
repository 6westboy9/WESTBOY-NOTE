
## 问题描述

从SQlServer读取到数据，且读取出来的数据是个时间字符串“1990-08-27 00:00:00”。但是最终同步到MySQL库中值为1990-08-26 23:00:00。

## 问题分析


通过Arthas查看birthDate=Mon Aug 27 00:00:00 CDT 1990，最终各种资料查询结果是因为夏令时所导致，详细说明参见：https://juejin.cn/post/6844903892216463374

### 问题复现

```java
import java.sql.Timestamp;  
import java.text.ParseException;  
import java.text.SimpleDateFormat;  
import java.util.Date;  
import java.util.TimeZone;

public class TimeTest {
	public static void main(String[] args) throws ParseException {  
		System.out.println("当前的默认时区为: " + TimeZone.getDefault().getID());  
		String dateStr1 = "1988-07-29 00:00:00"; // 在夏令时
		String dateStr2 = "1983-07-29 00:00:00"; // 不在夏令时
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
		Date date1 = dateFormat.parse(dateStr1);  
		Date date2 = dateFormat.parse(dateStr2);  
		long time1 = date1.getTime();  
		long time2 = date2.getTime();  
		System.out.println("[转换前]在中国夏令时范围内的时间   date1=" + date1 + " l1=" + time1);  
		System.out.println("[转换前]正常东八区时间            date2=" + date2 + " l2=" + time2);  

        // java.sql.Timestamp 模拟数据库入库前的日期转换
		Timestamp timestamp1 = Timestamp.valueOf(dateStr1);  
		Timestamp timestamp2 = Timestamp.valueOf(dateStr2);  
		// 模拟数据库时区设置
		// jdbc:mysql://10.2.3.167:3306/windranger_prcc?characterEncoding=utf8&allowMultiQueries=true&serverTimezone=GMT%2B8
		TimeZone zone = TimeZone.getTimeZone("GMT+8");  
		TimeZone.setDefault(zone);  
		System.out.println(TimeZone.getDefault().getID());  
		System.out.println("[转换后]在中国夏令时范围内的时间   timestamp1=" + timestamp1 + ", l1=" + timestamp1.getTime());  
		System.out.println("[转换后]正常东八区时间            timestamp2=" + timestamp2 + ", l2=" + timestamp2.getTime());  
	}
}
```

输出结果：

```
当前的默认时区为: Asia/Shanghai
[转换前]在中国夏令时范围内的时间   date1=Fri Jul 29 00:00:00 CDT 1988 l1=586105200000
[转换前]正常东八区时间            date2=Fri Jul 29 00:00:00 CST 1983 l2=428256000000
GMT+08:00
[转换后]在中国夏令时范围内的时间   timestamp1=1988-07-28 23:00:00.0, l1=586105200000
[转换后]正常东八区时间            timestamp2=1983-07-29 00:00:00.0, l2=428256000000
```

原因就是Asia/Shanghai是支持夏令时的，GMT+8不支持。

从上面看时间戳是不会有问题，所以也就理解了DBA推荐时间使用时间戳整形，而非日期类型。

### 统一时区均为GMT+8

```java
public static void main(String[] args) throws ParseException {  
    TimeZone zone = TimeZone.getTimeZone("GMT+8");  
    TimeZone.setDefault(zone);  
  
    System.out.println("当前的默认时区为: " + TimeZone.getDefault().getID());  
    String dateStr1 = "1988-07-29 00:00:00"; // 在夏令时  
    String dateStr2 = "1983-07-29 00:00:00"; // 不在夏令时  
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
    Date date1 = dateFormat.parse(dateStr1);  
    Date date2 = dateFormat.parse(dateStr2);  
    long time1 = date1.getTime();  
    long time2 = date2.getTime();  
    System.out.println("[转换前]在中国夏令时范围内的时间   date1=" + date1 + " l1=" + time1);  
    System.out.println("[转换前]正常东八区时间            date2=" + date2 + " l2=" + time2);  
  
    Timestamp timestamp1 = Timestamp.valueOf(dateStr1);  
    Timestamp timestamp2 = Timestamp.valueOf(dateStr2);  
  
    System.out.println("[转换后]在中国夏令时范围内的时间   timestamp1=" + timestamp1 + ", l1=" + timestamp1.getTime());  
    System.out.println("[转换后]正常东八区时间            timestamp2=" + timestamp2 + ", l2=" + timestamp2.getTime());  
}
```

输出结果：

```
当前的默认时区为: GMT+08:00
[转换前]在中国夏令时范围内的时间   date1=Fri Jul 29 00:00:00 GMT+08:00 1988 l1=586108800000
[转换前]正常东八区时间            date2=Fri Jul 29 00:00:00 GMT+08:00 1983 l2=428256000000
GMT+08:00
[转换后]在中国夏令时范围内的时间   timestamp1=1988-07-29 00:00:00.0, l1=586108800000
[转换后]正常东八区时间            timestamp2=1983-07-29 00:00:00.0, l2=428256000000
```

### 统一时区均为默认Asia/Shanghai

```java
public static void main(String[] args) throws ParseException {  
    System.out.println("当前的默认时区为: " + TimeZone.getDefault().getID());  
    String dateStr1 = "1988-07-29 00:00:00"; // 在夏令时  
    String dateStr2 = "1983-07-29 00:00:00"; // 不在夏令时  
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
    Date date1 = dateFormat.parse(dateStr1);  
    Date date2 = dateFormat.parse(dateStr2);  
    long time1 = date1.getTime();  
    long time2 = date2.getTime();  
    System.out.println("[转换前]在中国夏令时范围内的时间   date1=" + date1 + " l1=" + time1);  
    System.out.println("[转换前]正常东八区时间            date2=" + date2 + " l2=" + time2);  
  
    Timestamp timestamp1 = Timestamp.valueOf(dateStr1);  
    Timestamp timestamp2 = Timestamp.valueOf(dateStr2);  
  
    System.out.println("[转换后]在中国夏令时范围内的时间   timestamp1=" + timestamp1 + ", l1=" + timestamp1.getTime());  
    System.out.println("[转换后]正常东八区时间            timestamp2=" + timestamp2 + ", l2=" + timestamp2.getTime());  
}
```

输出结果：

```
当前的默认时区为: Asia/Shanghai
[转换前]在中国夏令时范围内的时间   date1=Fri Jul 29 00:00:00 CDT 1988 l1=586105200000
[转换前]正常东八区时间            date2=Fri Jul 29 00:00:00 CST 1983 l2=428256000000
Asia/Shanghai
[转换后]在中国夏令时范围内的时间   timestamp1=1988-07-29 00:00:00.0, l1=586105200000
[转换后]正常东八区时间           timestamp2=1983-07-29 00:00:00.0, l2=428256000000
```

## 问题解决


那么如何解决呢？其实上面分析已经差不多了，主要是统一时区，那么如何统一呢？


方案一：统一JVM时区与MySQL驱动上设置的一致，可以直接在JVM启动参数上设置时区为GMT+8

```
-Duser.timezone=GMT+8
```

方案二：设置MySQL驱动

```
jdbc:mysql://10.2.3.167:3306/windranger_prcc?characterEncoding=utf8&allowMultiQueries=true&serverTimezone=Asia/Shanghai
```

## 部分夏令时JDK判断不同版本存在差异


不同JDK版本原生自带判断夏令时的TimeZone#inDaylightTime方法，返回结果可能不同。

```java
TimeZone timeZone = TimeZone.getDefault();
System.out.printf("TimeZoneID:%s%n", TimeZone.getDefault().getID());

SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date date1 = format.parse("1988-07-29 00:00:00"); // 在夏令时
Date date2 = format.parse("1990-09-16 00:00:00"); // 在夏令时
Date date3 = format.parse("1983-07-29 00:00:00"); // 不在夏令时

// joda-time工具类
DateTimeZone dateTimeZone = DateTimeZone.getDefault();

// boolean result = timeZone.inDaylightTime(date) && timeZone.useDaylightTime();
System.out.printf("%s : %s | %s | %s%n", date1.toString(), timeZone.useDaylightTime(), timeZone.inDaylightTime(date1), dateTimeZone.isStandardOffset(date1.getTime()));
System.out.printf("%s : %s | %s | %s%n", date2.toString(), timeZone.useDaylightTime(), timeZone.inDaylightTime(date2), dateTimeZone.isStandardOffset(date2.getTime()));
System.out.printf("%s : %s | %s | %s%n", date3.toString(), timeZone.useDaylightTime(), timeZone.inDaylightTime(date3), dateTimeZone.isStandardOffset(date3.getTime()));
```

```shell
# java -version
java version "1.8.0_381"
Java(TM) SE Runtime Environment (build 1.8.0_381-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.381-b09, mixed mode)

# 执行结果
TimeZoneID:Asia/Shanghai
Fri Jul 29 00:00:00 CDT 1988 : false | true | false
Sun Sep 16 00:00:00 CDT 1990 : false | true | false   # 注意 timeZone.inDaylightTime(date2)返回结果为true（期望结果）
Fri Jul 29 00:00:00 CST 1983 : false | false | true
```

```shell
# java -version
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)

# 执行结果
TimeZoneID:Asia/Shanghai
Fri Jul 29 00:00:00 CDT 1988 : false | true | false
Sun Sep 16 00:00:00 CST 1990 : false | false | false # 注意 timeZone.inDaylightTime(date2)返回结果为false（意外结果）
Fri Jul 29 00:00:00 CST 1983 : false | false | true
```

可以看到<font color="#f79646">部分夏令时（并非所有）</font>使用原生的JDK自带工具方法判断不同版本会存在差异，改用joda-time开源工具不同版本不会存在差异（至少目前使用的版本），那具体原因是什么呢？

## 刨根问底


### 数据库时区查询


```sql
show variables like '%time_zone%';
```

![[Pasted image 20231027112626.png|330]]

### 作系统时区查询

```
# readlink /etc/localtime
../usr/share/zoneinfo/Asia/Shanghai
```

### 代码执行链路追踪


mysql-connector-java.8.0.13版本

方法路径：com.mysql.cj.ClientPreparedQueryBindings#setTimestamp(int, java.sql.Timestamp, java.util.Calendar, int)

#### 更新或新增时设置时间

从下望上

```
at com.mysql.cj.ClientPreparedQueryBindings.setTimestamp(ClientPreparedQueryBindings.java:798)
at com.mysql.cj.ClientPreparedQueryBindings.setTimestamp(ClientPreparedQueryBindings.java:757)
at com.mysql.cj.jdbc.ClientPreparedStatement.setTimestamp(ClientPreparedStatement.java:1807)
at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.setTimestamp(HikariProxyPreparedStatement.java)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.apache.ibatis.logging.jdbc.PreparedStatementLogger.invoke(PreparedStatementLogger.java:67)
at com.sun.proxy.$Proxy81.setTimestamp(Unknown Source)
at org.apache.ibatis.type.DateTypeHandler.setNonNullParameter(DateTypeHandler.java:33)
at org.apache.ibatis.type.DateTypeHandler.setNonNullParameter(DateTypeHandler.java:28)
at org.apache.ibatis.type.BaseTypeHandler.setParameter(BaseTypeHandler.java:69)
at org.apache.ibatis.scripting.defaults.DefaultParameterHandler.setParameters(DefaultParameterHandler.java:87)
at org.apache.ibatis.executor.statement.PreparedStatementHandler.parameterize(PreparedStatementHandler.java:94)
at org.apache.ibatis.executor.statement.RoutingStatementHandler.parameterize(RoutingStatementHandler.java:64)
at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:88)
at org.apache.ibatis.executor.SimpleExecutor.doUpdate(SimpleExecutor.java:49)
at org.apache.ibatis.executor.BaseExecutor.update(BaseExecutor.java:117)
```


![[Pasted image 20231027135411.png|900]]

#### 读取时获取时间

```
at com.mysql.cj.result.SqlTimestampValueFactory.createFromTimestamp(SqlTimestampValueFactory.java:101)
at com.mysql.cj.result.SqlTimestampValueFactory.createFromTimestamp(SqlTimestampValueFactory.java:46)
at com.mysql.cj.result.BaseDecoratingValueFactory.createFromTimestamp(BaseDecoratingValueFactory.java:61)
at com.mysql.cj.result.BaseDecoratingValueFactory.createFromTimestamp(BaseDecoratingValueFactory.java:61)
at com.mysql.cj.protocol.a.MysqlTextValueDecoder.decodeTimestamp(MysqlTextValueDecoder.java:183)
at com.mysql.cj.protocol.result.AbstractResultsetRow.decodeAndCreateReturnValue(AbstractResultsetRow.java:87)
at com.mysql.cj.protocol.result.AbstractResultsetRow.getValueFromBytes(AbstractResultsetRow.java:250)
at com.mysql.cj.protocol.a.result.ByteArrayRow.getValue(ByteArrayRow.java:91)
at com.mysql.cj.jdbc.result.ResultSetImpl.getNonStringValueFromRow(ResultSetImpl.java:656)
at com.mysql.cj.jdbc.result.ResultSetImpl.getDateOrTimestampValueFromRow(ResultSetImpl.java:679)
at com.mysql.cj.jdbc.result.ResultSetImpl.getTimestamp(ResultSetImpl.java:1019)
at com.mysql.cj.jdbc.result.ResultSetImpl.getObject(ResultSetImpl.java:1359)
at com.zaxxer.hikari.pool.HikariProxyResultSet.getObject(HikariProxyResultSet.java)
at org.springframework.jdbc.support.JdbcUtils.getResultSetValue(JdbcUtils.java:266)
at org.springframework.jdbc.core.ColumnMapRowMapper.getColumnValue(ColumnMapRowMapper.java:97)
at org.springframework.jdbc.core.ColumnMapRowMapper.mapRow(ColumnMapRowMapper.java:58)
at org.springframework.jdbc.core.ColumnMapRowMapper.mapRow(ColumnMapRowMapper.java:49)
at org.springframework.jdbc.core.RowMapperResultSetExtractor.extractData(RowMapperResultSetExtractor.java:94)
at org.springframework.jdbc.core.RowMapperResultSetExtractor.extractData(RowMapperResultSetExtractor.java:61)
at org.springframework.jdbc.core.JdbcTemplate$1QueryStatementCallback.doInStatement(JdbcTemplate.java:440)
at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:376)
at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:452)
at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:462)
at org.springframework.jdbc.core.JdbcTemplate.queryForList(JdbcTemplate.java:490)
at com.lachesis.datasync.view.impl.BaseDao.extractTop10(BaseDao.java:252)
```


## 推荐资料

* [GMT UTC CST ISO 夏令时 时间戳，都是些什么鬼？](https://mp.weixin.qq.com/s/VdoQt88JfjPJTL9XgohZJQ)

