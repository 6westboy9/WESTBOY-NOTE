
- [Chapter 6. The Java Virtual Machine Instruction Set](https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-6.html#jvms-6.5)
- [JVM字节码指令手册_肖朋伟的博客-CSDN博客](https://blog.csdn.net/qq_40147863/article/details/99655005)

# 概述
## 1.加载和存储指令

|描述|指令|
|---|---|
|局部变量表 → 操作数栈<br><font color="#f79646">变量</font>|`iload`和`iload_<i>` int<br>`lload`和`lload_<i>` long<br>`fload`和`fload_<i>` float<br>`dload`和`dload_<i>` double<br>`aload`和`aload_<i>` reference|
|操作数栈 → 局部变量表<br><font color="#f79646">变量</font>|`istore`和`istore_<i>` int<br>`lstore`和`lstore_<i>` long<br>`fstore`和`fstore_<i>` float<br>`dstore`和`dstore_<i>` double<br>`astore`和`astore_<i>` reference|
|局部变量表 → 操作数栈<br><font color="#f79646">运行时常量</font>|`bipush` byte<br>`sipush` short<br>`ldc` Push item from run-time constant pool<br>`ldc_w` Push item from run-time constant pool (wide index)<br>`ldc2_w` Push long or double from run-time constant pool (wide index)<br>`aconst_null` Push the null object reference onto the operand stack.<br>`iconst_<i>` Push the int constant `<i>` (-1, 0, 1, 2, 3, 4 or 5) onto the operand stack.<br>`lconst_<l>` Push the long constant `<l>` (0 or 1) onto the operand stack.<br>`fconst_<f>` Push the float constant `<f>` (0.0, 1.0, or 2.0) onto the operand stack.<br>`dconst_<d>` Push the double constant `<d>` (0.0 or 1.0) onto the operand stack.|
|局部变量表 → 操作数栈<br><font color="#f79646">数组</font>||
|操作数栈 → 局部变量表<br><font color="#f79646">数组</font>||

>对于boolean、byte、short、char和int这5种类型，均会转换成int类型（统一处理）~



### 加载

将一个局部变量加载到操作数栈中的指令。



### 存储

将值从操作数栈存储到局部变量表的指令。


## 2.算数指令


## 3.类型转换指令


## 4.对象的创建和操作指令

对象创建以后，就可以通过对象访问指令来获取对象实例中的字段和数组实例中的数组元素，这些指令汇总如下。

* 创建类实例的指令：`new`。
* 创建数组的指令：`newarray`、`anewarray`、`multianewarray`。
* 访问实例字段的指令：`getfield`、`putfield`。
* 访问类字段的指令：`getstatic`、`putstatic`。
* 将数组值从局部变量表加载到操作数栈的指令：`baload`、`caload`、`saload`、`iaload`、`laload`、`faload`、`daload`、`aaload`。
* 将操作数栈中的数组值存储到局部变量表中的指令：`bastore`、`castore`、`sastore`、`iastore`、lastore、`fastore`、`dastore`、`aastore`。
* 取数组长度的指令：`arraylength`。
* 检查类实例或数组类型的指令：`instanceof`、`checkcast`。

## 5.操作数栈管理指令


## 6.控制转移指令


## 7.方法调用和返回指令

在字节码指令中，与方法调用相关的指令有如下5种：

- `invokestatic`：该指令用于调用静态方法。
- `invokeinterface`：该指令用于调用接口方法。
- `invokespecial`：该指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
- `invokevirtual`：该指令用于调用对象的实例方法。
- `invokedynamic`：该指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。


## 8.异常抛出指令



## 9.同步指令


# 详述


## `dup`相关指令

用于复制栈顶的数值并将其副本推送到栈顶。`dup`指令有几种不同的变体，用于复制不同类型的数值。

1. `dup`指令：
    - 操作码：`0x59`
    - 功能：复制栈顶的一个字长数值（可以是基本类型或引用），并将复制的值推送到栈顶。结果栈的深度增加1。
2. `dup_x1`指令：
    - ·操作码：`0x5A`
    - 功能：复制栈顶的一个字长数值，并将复制的值插入栈顶下面的两个元素之间。结果栈的深度增加1。
3. `dup_x2`指令：
    - 操作码：`0x5B`
    - 功能：复制栈顶的一个字长数值，并将复制的值插入栈顶下面的三个元素之间。结果栈的深度增加1。
4. `dup2`指令：
    - 操作码：`0x5C`
    - 功能：复制栈顶的两个字长数值（可以是基本类型或引用），并将复制的值推送到栈顶。结果栈的深度增加2。
5. `dup2_x1`指令：
    - 操作码：`0x5D`
    - 功能：复制栈顶的两个字长数值，并将复制的值插入栈顶下面的三个元素之间。结果栈的深度增加2。
6. `dup2_x2`指令：
    - 操作码：`0x5E`
    - 功能：复制栈顶的两个字长数值，并将复制的值插入栈顶下面的四个元素之间。结果栈的深度增加2。


# 问题

## 为什么`new`指令后执行`dup`指令？

```
1. new               // 创建对象后，保留一个引用，结果为： ref
2. dup               // 赋值引用后，保留两个引用，结果为： ref,ref
3. invokespecial     // 调用了构造方法用一个引用，结果为： ref
```

如果不使用`dup`复制，<font color="#f79646">被构造函数指令使用后，最终无法返回实例引用</font>，即调用构造函数之后，会消耗一个ref，如果不使用`dup`指令：

```
1. new               // 创建对象后，保留一个引用，结果为： ref
2. invokespecial     // 调用了构造方法用一个引用，结果为： 
```

操作数栈没有了ref，就没办法返回了实例引用了~

