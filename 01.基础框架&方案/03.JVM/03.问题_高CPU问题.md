* [Java程序CPU占用过高故障排除 - 大峰哥的博客](https://dafengge0913.github.io/java-high-cpu-troubleshooting/)
* [Java进程CPU占用高如何排查](https://blog.csdn.net/jwentao01/article/details/115461695)
* [Java正则表达式导致CPU利用率居高不下](https://blog.csdn.net/weixin_33023873/article/details/114740786)

# 1.查看资源占用情况

```shell
top
```

![[Pasted image 20240816101747.png|L|600]]
# 2.查看对应程序

```shell
# JVM程序的话，也可以使用jps命令查看
ps aux | grep 22210
```

![[Pasted image 20240816102004.png|L|1000]]

# 3.查看进程中所有线程的资源占用

找出是哪个线程造成了高CPU使用率

```
top -p 22210 -H
```

![[Pasted image 20240816102039.png|L|700]]


# 4.查看线程快照

```
// 上述红色部分 22226转十六进制56d2
jstack 22210 | grep -A 100 56d2
jstack 10616 | grep -A 100 2988
```

* 22210对应线程ID
* 56d2：对应第3步骤结果中的PID，比如这里选22226，那么对应的十六进制是56d2，并且字母要小写！

# 5.现象


## 1_服务器假死到OOM

进程在，但是服务器不能响应。

![[Pasted image 20250829162338.png|L|600]]


但是有时候我们并不能根据线程Id就能查出有问题的代码在哪里，比如上图线程一直在进行GC，也就是说造成Java服务进程假死的原因是因为JVM的长时间GC导致的Stop The World！

### 1.jstat命令排查GC信息

![[Pasted image 20250829162606.png|L|600]]

### 2.jmap命令拿到dump日志文件

```sh
jmap -dump:format=b,file=heapdump.hprof 10616
```

一般会很慢...

其实在dump之后，发现了oom的日志，下面主要分析oom的日志文件。

### 3.MAT分析

![[Pasted image 20250829165818.png|L|800]]

### 4.OOM日志

```sh
grep "Metaspace" LOGS/log_error.log
# 或者
grep "java.lang.OutOfMemoryError" LOGS/log_error.log
```

![[Pasted image 20250829165908.png|L|500]]

### 5.解决方案

调大元空间~


## 2_编码问题



