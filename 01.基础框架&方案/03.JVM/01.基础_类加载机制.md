# 类加载过程


## 主动引用与被动引用

虚拟机规范严格规定有且只有5种情况必须立即对类进行初始化，称为<font color="#f79646">主动引用</font>。 --- 固然加载、验证、准备自然需要在此之前开始~

1. 遇到new/getstatic/putstatic/invokestatic字节码指令，生成这4条指令的最常见场景：
	 - 使用new实例化对象。
	 - 读写一个类的静态字段。<font color="#4bacc6">被final修饰，已在编译器把结果放入常量池的静态字段除外~</font>
	 - 调用类的静态方法。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类时，如果其父类还没初始化，需先初始化父类。
	- 在此，<font color="#4bacc6">类与接口具有不同的表现</font>，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。
	- 注意，<font color="#4bacc6">接口的实现类在初始化时也一样不会要求接口完成初始化</font>。
4. 当虚拟机启动时，用户需要指定一个执行的主类，即包含main方法的那个类，虚拟机会先初始化这个主类。
5. JDK1.7动态语言支持：如果一个java.lang.invoke.MethodHandle的实例最后的解析结果为REF_getStatic/REF_putStatic/REF_invokeStatic的方法句柄，并且这个方法所对应的类没有进行过初始化，则需要先触发其初始化。

除上面主动引用的5中情况之外都不会触发初始化，称为<font color="#f79646">被动引用</font>，主要列举以下3种情况：

1. 通过子类引用父类静态字段，只会导致父类的初始化而不会导致子类初始化。HotSpot可通过-XX:+TraceClassLoading参数导致子类的加载。
	- `Person[] arr = new Person[10]`不会触发Person类初始化。
	- 通过`static final`修饰的变量在编译阶段会存入调用类的常量池，进而通过XXXClass.VAR引用不会触发XXXClass初始化。
		- 注意，当一个常量的值并非编译期间可以确定，那么其值就不会放入调用类的常量池中，因此当使用该常量值，就会导致该常量所在类的初始化。
2. 调用ClassLoader#loadClass方法不会导致类的初始化。

## 类的生命周期


简单说类的生命周期分为5个阶段：

1. 加载
2. 连接
	1. 验证
	2. 准备
	3. 解析
3. 初始化
4. 使用
5. 卸载

### 加载

类的加载指的是将类的class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象用来封装类在方法区内的数据结构。

* JVM规范中并未说明Class对象位于哪里，<font color="#f79646">Hotspot虚拟机将其放在方法区中</font>。
* JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，<font color="#f79646">如果在预先加载的过程中遇到了class文件缺失或存在错误，类加载器会在程序首次主动引用该类时报告LinkageError错误</font>。如果这个类一直没有被程序主动引用，那么类加载器就不会报告错误。
* 启动Java程序时通过`-XX:+TraceClassLoading`可以打印类的加载信息。

测试案例

```java
public class MyTest01 {  
    public static void main(String[] args) {  
        System.out.println("hello");  
    }  
}
```

```shell
$ cd D:\IdeaProjects\mine\westboy-hub\base-jvm\base-jvm-book\target\classes
$ java -XX:+TraceClassLoading com.westboy.base.jvm.book.MyTest01
```

```
[Opened D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar]
[Loaded java.lang.Object from D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar]                    
[Loaded java.io.Serializable from D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar]                
...
[Loaded java.security.BasicPermissionCollection from D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar]
[Loaded com.westboy.base.jvm.book.MyTest01 from file:/D:/IdeaProjects/mine/westboy-hub/base-jvm/base-jvm-book/target/classes/]
[Loaded sun.launcher.LauncherHelper$FXHelper from D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar]
[Loaded java.lang.Class$MethodArray from D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar]
[Loaded java.lang.Void from D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar]
hello
[Loaded java.lang.Shutdown from D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar]
[Loaded java.lang.Shutdown$Lock from D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar]
```

#### 加载来源

类加载的class文件的来源：

*  从ZIP包中读取；
* 从网络中获取；
* 运行时计算生成，比如动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass类来为特定接口生成形式为$Proxy的代理类的二进制字节流；
* 有其他文件生成，比如JSP；
* 从数据库中读取。

>字节码加解密时，自定义类加载器在类的加载阶段进行解密工作。

#### 加载时机

网上看到好多资料都是将主动引用定义为类加载的时机，感觉这里有问题，主动引用会引发类的初始化，而加载在初始化之前，必然会导致类需要加载。

但是，被动引用中的ClassLoader#loadClass方法也可以将类加载呀~

==TODO 待考究~==

#### 加载方式

类加载有三种方式：

* 命令行启动应用时候由<font color="#f79646">JVM初始化</font>加载。
* 通过<font color="#f79646">Class#forName</font>方法动态加载。
* 通过<font color="#f79646">ClassLoader#loadClass</font>方法动态加载。

第二种和第三种方式的区别：

* Class.forName(name)：<font color="#4bacc6">静态方法</font>，将类文件加载，连接，<font color="#f79646">初始化完成</font>。如果类已经被加载，连接和初始化过了，<font color="#f79646">再次调用Class.forName(name)不会重新加载和初始化该类</font>。
* ClassLoader.loadClass(name)：<font color="#4bacc6">实例方法</font>，只干一件事情，就是将类文件加载到JVM中，<font color="#f79646">不会连接也不会进行初始化</font>，连接和初始化是首次主动引用时，才进行的，比如调用newInstance方法时。

那么它两加载类是通过哪个类加载器呢？

* Class.forName(name)：默认使用调用它的类的类加载器，也可以指定类加载器。
* ClassLoader.loadClass(name)：取决于ClassLoader的实现。


查看Class.forName(name)源码：

```java
public static Class<?> forName(String className) throws ClassNotFoundException {
	Class<?> caller = Reflection.getCallerClass();
	return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
}
```

查看另外一个Class.forName(name, initialize, loader)源码：

通过参数<font color="#f79646">可控制是否进行类的初始化操作</font>。

```java
public static Class<?> forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException {
	Class<?> caller = null;
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
		// Reflective call to get caller class is only needed if a security manager
		// is present.  Avoid the overhead of making this call otherwise.
		caller = Reflection.getCallerClass();
		if (sun.misc.VM.isSystemDomainLoader(loader)) {
			ClassLoader ccl = ClassLoader.getClassLoader(caller);
			if (!sun.misc.VM.isSystemDomainLoader(ccl)) {
				sm.checkPermission(
					SecurityConstants.GET_CLASSLOADER_PERMISSION);
			}
		}
	}
	return forName0(name, initialize, loader, caller);
}
```


### 连接


<font color="#f79646">验证</font>


<font color="#f79646">准备</font>


<font color="#f79646">解析</font>


### 初始化


### 使用


### 卸载



# 类加载器

>环境：JDK 1.8

<font color="#4bacc6">Bootstrap ClassLoader</font>

启动类加载器（也称根类加载器）：该类加载器负责加载`$JAVA_HOME/jre/lib`或者由`-Xbootclasspath`参数（或者使用`-D`选项指定`sun.boot.class.path`）所指定的路径中的，并且是虚拟机识别的类库到虚拟机内存中。<font color="#f79646">启动类加载器无法被Java程序直接引用</font><font color="#f79646">，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用null代替即可</font>。

<font color="#4bacc6">Extension ClassLoader</font>

扩展类加载器：这个加载器由`sun.misc.Launcher$ExtClassLoader`实现。它负责加载`$JAVA_HOME/jre/lib/ext`或者由`java.ext.dirs`指定的目录中的jar包的类。通过这种方式，就可以为Java扩展核心类以外的新功能，只要把自己开发的类打成JAR文件，然后放入`$JAVA_HOME/jre/lib/ext`路径即可。

<font color="#4bacc6">System ClassLoader</font>

系统类加载器（也称应用类加载器）：这个加载器由`sun.misc.Launcher$AppClassLoader`实现。它负责在JVM启动时加载路径有：

1. 来自java命令的-classpath选项。
2. java.class.path系统属性。
3. CLASSPATH环境变量所指定的jar包和类路径。

可以用通过ClassLoader的静态方法getSystemClassLoader方法来获取系统类加载器。

如果没有特别指定，则用户自定义的类加载器都以应用类加载器作为父加载器。


```java
public class MyTest19 {  
    public static void main(String[] args) {  
        print("sun.boot.class.path", "启动类加载器");  
        print("java.ext.dirs", "扩展类加载器");  
        print("java.class.path", "应用类加载器");  
    }  
  
    private static void print(String path, String classLoaderName) {  
        System.out.println(classLoaderName + "加载路径: ");  
        for (String v : System.getProperty(path).split(File.pathSeparator)) {  
            System.out.println(v);  
        }  
    }  
}
```

<font color="#f79646">Windows Java命令运行</font>

```
java MyTest19
```

```
启动类加载器加载路径: 
$JAVA_HOME\jre\lib\resources.jar
$JAVA_HOME\jre\lib\rt.jar
$JAVA_HOME\jre\lib\sunrsasign.jar
$JAVA_HOME\jre\lib\jsse.jar
$JAVA_HOME\jre\lib\jce.jar
$JAVA_HOME\jre\lib\charsets.jar
$JAVA_HOME\jre\lib\jfr.jar
$JAVA_HOME\jre\classes
扩展类加载器加载路径:
$JAVA_HOME\jre\lib\ext
C:\Windows\Sun\Java\lib\ext                                          // Windows下自定义扩展目录
应用类加载器加载路径:
.
$JAVA_HOME\lib
$JAVA_HOME\lib\dt.jar
$JAVA_HOME\lib\tools.jar
```

应用类加载器加载路径主要由配置的环境变量`CLASSPATH`决定，查看Windows中配置的环境变量：

![[Pasted image 20231102133818.png|600]]

<font color="#f79646">Windows IDEA运行</font>

```
启动类加载器加载路径: 
$JAVA_HOME\jre\lib\resources.jar
$JAVA_HOME\jre\lib\rt.jar
$JAVA_HOME\jre\lib\sunrsasign.jar
$JAVA_HOME\jre\lib\jsse.jar
$JAVA_HOME\jre\lib\jce.jar
$JAVA_HOME\jre\lib\charsets.jar
$JAVA_HOME\jre\lib\jfr.jar
$JAVA_HOME\jre\classes
扩展类加载器加载路径: 
$JAVA_HOME\jre\lib\ext
C:\Windows\Sun\Java\lib\ext                                        // Windows下自定义扩展目录
应用类加载器加载路径: 
$JAVA_HOME\jre\lib\charsets.jar
$JAVA_HOME\jre\lib\deploy.jar
$JAVA_HOME\jre\lib\ext\access-bridge-64.jar
$JAVA_HOME\jre\lib\ext\cldrdata.jar
$JAVA_HOME\jre\lib\ext\dnsns.jar
$JAVA_HOME\jre\lib\ext\jaccess.jar
$JAVA_HOME\jre\lib\ext\jfxrt.jar
$JAVA_HOME\jre\lib\ext\localedata.jar
$JAVA_HOME\jre\lib\ext\nashorn.jar
$JAVA_HOME\jre\lib\ext\sunec.jar
$JAVA_HOME\jre\lib\ext\sunjce_provider.jar
$JAVA_HOME\jre\lib\ext\sunmscapi.jar
$JAVA_HOME\jre\lib\ext\sunpkcs11.jar
$JAVA_HOME\jre\lib\ext\zipfs.jar
$JAVA_HOME\jre\lib\javaws.jar
$JAVA_HOME\jre\lib\jce.jar
$JAVA_HOME\jre\lib\jfr.jar
$JAVA_HOME\jre\lib\jfxswt.jar
$JAVA_HOME\jre\lib\jsse.jar
$JAVA_HOME\jre\lib\management-agent.jar
$JAVA_HOME\jre\lib\plugin.jar
$JAVA_HOME\jre\lib\resources.jar
$JAVA_HOME\jre\lib\rt.jar
.                                                                   // 当前MyTest19.class文件所在目录
D:\Program Files\JetBrains\IntelliJ IDEA 2023.2.2\lib\idea_rt.jar   // 使用IDEA运行MyTest19#main时
```

可以看到IDEA还是做了些手脚的，具体哪些手脚呢？<font color="#4bacc6">遗留待完成~</font>

<font color="#f79646">CentOS7 Java命令运行</font>

```
java MyTest19
```

```
启动类加载器加载路径: 
$JAVA_HOME/jre/lib/resources.jar
$JAVA_HOME/jre/lib/rt.jar
$JAVA_HOME/jre/lib/jsse.jar
$JAVA_HOME/jre/lib/jce.jar
$JAVA_HOME/jre/lib/charsets.jar
$JAVA_HOME/jre/lib/jfr.jar
$JAVA_HOME/jre/classes
扩展类加载器加载路径: 
$JAVA_HOME/jre/lib/ext
/usr/java/packages/lib/ext                                          // Linux下自定义扩展目录
应用类加载器加载路径: 
.
$JAVA_HOME/jre/lib/rt.jar
$JAVA_HOME/lib/dt.jar
$JAVA_HOME/lib/tools.jar
```

应用类加载器加载路径主要由配置的环境变量`CLASSPATH`决定，查看CentOS7中配置的环境变量：

```
$ echo $CLASSPATH
.:{JAVA_HOME}/jre/lib/rt.jar:{JAVA_HOME}/lib/dt.jar:{JAVA_HOME}/lib/tools.jar
```

## 双亲委派模型

所谓双亲委派模型是指一个类加载器在加载某个类时，首先把委派给父加载器去加载，父加载器又委派给它的父加载器加载，如此顶层的启动类加载器为止，如果其父加载器在其搜索范围没有找到相应类，则尝试自己加载。

可以看出首先接收加载请求的类加载器并不一定真正加载类，可能由它的父加载器完成加载，接收加载请求的类加载器叫做<font color="#f79646">初始类加载器</font>（initiating loader），而完成加载的类加载器叫做<font color="#f79646">定义类加载器</font>（defining loader），<font color="#f79646">初始类加载器和定义类加载器可能相同也可能不同</font>。

源码实现：

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // 一个类的加载是放在代码同步块里边的，所以不会有同一个类加载多次
	synchronized (getClassLoadingLock(name)) {
		// 首先检查该类是否已加载过
		Class<?> c = findLoadedClass(name);
		// 如果缓存中没有找到，则按双亲委派模型加载
		if (c == null) {
			long t0 = System.nanoTime();
			try {
				if (parent != null) {
				    // 如果父加载器不为null，则代理给父加载器加载
				    // 父加载器在自己搜索范围内找不到该类，则抛出ClassNotFoundException
					c = parent.loadClass(name, false);
				} else {
				    // 如果父加载器为null，则从启动类加载器加载
				    // 找是否加载过此类，找不到返回null
					c = findBootstrapClassOrNull(name);
				}
			} catch (ClassNotFoundException e) {
				// 存在父加载器，但父加载器没有找到要加载的类，触发此异常
				// 捕获不处理，交给子加载器自身去加载
			}

			if (c == null) {
				// 如果从父加载器到顶层加载器（启动类加载器）都找不到此类，则自己来加载
				long t1 = System.nanoTime();
				c = findClass(name);

				// 类加载的统计信息
				sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
				sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
				sun.misc.PerfCounter.getFindClasses().increment();
			}
		}
		
		// 如果resolve指定为true，则立即进入链接阶段
		if (resolve) {
			resolveClass(c);
		}
		return c;
	}
}
```

通过源码可以看出，所有的类都优先委派给父加载器加载，如果父加载器无法加载，则自己来加载，逻辑很简单，这样做的好处是不同层次的类交给不同的加载器去加载，如`java.lang.Integer`最终都是由Bootstrap ClassLoader来加载的，这样只会有一个相同类被加载。

==使用Class#forName方法加载类，底层调用的是Classfor#Name0方法，是个native方法，那它是怎么个加载机制呢？与ClassLoader#loadClass方法有什么区别呢？==

*Class#forName方法*

* 它是java.lang.Class类的一个<font color="#f79646">静态方法</font>。
* 当调用Class#forName时，它会尝试加载并初始化指定名称name的类。这意味着它触发了类加载的加载、连接和初始化阶段。如果类还没有被加载，它会执行加载操作。
* Class#forName<font color="#f79646">默认使用的是当前线程的上下文类加载器</font>，它会按照双亲委派模型委托给父类加载器来加载类。这意味着它会在上层类加载器中寻找类，直到找到或抛出ClassNotFoundException。

*ClassLoader#loadClass方法*

* ClassLoader#loadClass方法是java.lang.ClassLoader类的方法，它是一个<font color="#f79646">实例方法</font>。
* 当你调用ClassLoader#loadClass时，它会加载指定name的类，但不会立即触发连接和初始化阶段。它<font color="#f79646">只会执行加载操作</font>。
* ClassLoader#loadClass通常是由<font color="#f79646">自定义的类加载器</font>来实现的，因此可以实现自定义的加载逻辑，例如从特定位置加载类。这个方法不一定遵循双亲委派模型，它可以根据类加载器的实现来决定加载方式。

## 自定义类加载器


自定义类加载器代码：

```java
public class MyClassLoader extends ClassLoader {  
  
    private final String classLoaderName;  
    private String path;  
    private final static String FILE_EXTENSION = ".class";  
  
    public MyClassLoader(String classLoaderName) {  
        // 将应用类加载器当做该类加载器的父类加载器  
        super();  
        this.classLoaderName = classLoaderName;  
    }  
  
    public MyClassLoader(ClassLoader parent, String classLoaderName) {  
        super(parent);  
        this.classLoaderName = classLoaderName;  
    }  
  
    public void setPath(String path) {  
        this.path = path;  
    }  
  
	@Override  
	public String toString() {  
	    return String.format("ClassLoaderName: %s", classLoaderName);  
	}  
  
    @Override  
    protected Class<?> findClass(String className) throws ClassNotFoundException {  
        // 验证是否使用我们自定义的类加载器  
        System.out.println("findClass invoked: " + className);  
        System.out.println("class loader name: " + this.classLoaderName);  
        byte[] data = this.loadClassData(className);  
        return this.defineClass(className, data, 0, data.length);  
    }  
  
    private byte[] loadClassData(String className) {  
        byte[] data = null;  
        className = className.replace(".", "/");  
        try (InputStream is = Files.newInputStream(new File(this.path + className + FILE_EXTENSION).toPath());  
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {  
            int ch;  
            while ((ch = is.read()) != -1) {  
                baos.write(ch);  
            }  
            data = baos.toByteArray();  
        } catch (Exception ex) {  
            ex.printStackTrace();  
        }  
        return data;  
    }  
}
```

使用我们自定义类加载器加载当前项目路径下的`com\westboy\base\jvm\book\MyTest19.class`代码：

```java
public class MyTest20 {  
    public static void main(String[] args) throws Exception {  
        String classPath = "D:\\IdeaProjects\\mine\\westboy-hub\\base-jvm\\base-jvm-book\\target\\classes";  
        String className = "com.westboy.base.jvm.book.MyTest19";  
  
        MyClassLoader loader1 = new MyClassLoader("loader1");  
        loader1.setPath(classPath);  
        Class<?> clazz1 = loader1.loadClass(className);  
  
        System.out.println("class1: " + clazz1.hashCode());  
        Object object1 = clazz1.newInstance();  
        System.out.println(object1);  
        System.out.println(object1.getClass().getClassLoader());  
  
        System.out.println();  
  
        MyClassLoader loader2 = new MyClassLoader("loader2");  
        loader2.setPath(classPath);  
        Class<?> clazz2 = loader2.loadClass(className);  
  
        System.out.println("class2: " + clazz2.hashCode());  
        Object object2 = clazz2.newInstance();  
        System.out.println(object2);  
        System.out.println(object2.getClass().getClassLoader());  
    }  
}
```

```
$ cd D:\\IdeaProjects\\mine\\westboy-hub\\base-jvm\\base-jvm-book\\target\\classes  // 当前项目路径
$ java com.westboy.base.jvm.book.MyTest20
```

输出结果如下：

```
class1: 1829164700
com.westboy.base.jvm.book.MyTest19@7852e922
sun.misc.Launcher$AppClassLoader@73d16e93

class2: 1829164700
com.westboy.base.jvm.book.MyTest19@4e25154f
sun.misc.Launcher$AppClassLoader@73d16e93
```

根据以上输出结果可见，<font color="#f79646">并没有使用我们自定义类加载器进行加载</font>，而是由应用类加载器所加载的。

<font color="#4bacc6">这是为什么？</font>

这是因为我们自己所定义的类加载器是将应用类加载器所加载作为父类加载器，根据双亲委派模型可知是由我们自定义类加载器的父类加载器，即应用类加载器所加载。同时loader1与loader2都是同一个父类加载器，因此可以看到class1.hashCode与class2.hashCode的值是一样的。
应用类加载器会加载当前路径下的所有class文件，而MyTest19.class就在当前路径下，因此会被应用类加载器加载，父类已经加载完成，那么我们自定义的类加载器就无需加载了~

<font color="#4bacc6">如何才能使用到我们自定义类加载器呢？</font>

将MyTest19.class文件移至另外一个非应用类加载器加载的目录，<font color="#f79646">防止应用类加载器加载</font>。这里我将其放置到了`D:\com\westboy\base\jvm\book`目录下，因此需要修改上面测试代码中的类路径：

```java
String classPath = "D:\\";
```

>注意当前路径下不应该存在MyTest19.class文件，否则执行结果会跟上面一样。

再次执行：

```
$ cd D:\IdeaProjects\mine\westboy-hub\base-jvm\base-jvm-book\target\classes
$ java com.westboy.base.jvm.book.MyTest20
```

输出结果：

```
findClass invoked: com.westboy.base.jvm.book.MyTest19
class loader name: loader1
class1: 1028566121
com.westboy.base.jvm.book.MyTest19@42a57993
ClassLoaderName: loader1

findClass invoked: com.westboy.base.jvm.book.MyTest19
class loader name: loader2
class2: 325040804
com.westboy.base.jvm.book.MyTest19@45ee12a7
ClassLoaderName: loader2
```

## 类的命名空间


* 每个类加载器都有自己的命名空间，<font color="#f79646">命名空间由加载该类的加载器及所有父类加载器所加载的类组成</font>。
* 在同一个命名空间中，不会出现类的完整名字（包括类的包名） 相同的两个类。
* 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。

>示例接着使用上文自定义类加载继续...

这时，上面我们自定义类加载器的第二个构造方法就有用了，测试代码如下：

```java
public class MyTest21 {

    public static void main(String[] args) throws Exception {
        String classPath = "D:\\";
        String className = "com.westboy.base.jvm.book.MyTest19";

        MyClassLoader loader1 = new MyClassLoader("loader1");
        loader1.setPath(classPath);
        // 不能是当前类
        Class<?> clazz = loader1.loadClass(className);
        Object object = clazz.newInstance();
        System.out.println("class HashCode: " + clazz.hashCode());
        System.out.println(object.getClass().getClassLoader());
        System.out.println("-----------------------");

        // 以loader1为父加载器
        MyClassLoader loader2 = new MyClassLoader(loader1, "loader2");
        loader2.setPath(classPath);
        // 不能是当前类
        Class<?> clazz1 = loader2.loadClass(className);
        Object object1 = clazz1.newInstance();
        System.out.println("class HashCode: " + clazz1.hashCode());
        System.out.println(object1.getClass().getClassLoader());
        System.out.println("-----------------------");

        MyClassLoader loader3 = new MyClassLoader("loader3");
        loader3.setPath(classPath);
        // 不能是当前类
        Class<?> clazz2 = loader3.loadClass(className);
        Object object2 = clazz2.newInstance();
        System.out.println("class HashCode: " + clazz2.hashCode());
        System.out.println(object2.getClass().getClassLoader());
    }
}
```

```
$ cd D:\IdeaProjects\mine\westboy-hub\base-jvm\base-jvm-book\target\classes
$ java com.westboy.base.jvm.book.MyTest21
```

输出结果：

```
findClass invoked: com.westboy.base.jvm.book.MyTest19
class loader name: loader1
class HashCode: 1028566121
ClassLoaderName: loader1
-----------------------
class HashCode: 1028566121
ClassLoaderName: loader1
-----------------------
findClass invoked: com.westboy.base.jvm.book.MyTest19
class loader name: loader3
class HashCode: 1836019240
ClassLoaderName: loader3
```

分析说明

* 因为当前路径下的类都是由AppClassLoader加载，但是此时已经删掉了对应的MyTest19.class文件，显然它是无法加载的， 根据双亲委托机制，委托一遍下来，都加载不了，就由自定义类加载器自己加载了。
* 上面的代码，loader2的父类加载是loader1，根据双亲委托机制，MyTest19.class类就由loader1加载，看看命名空间的定义，前面两个类加载器的命名空间一样，都是以loader1为准，所以相同类就只加载一次。
* 再看loader3，它的直接父类加载器就是AppClassLoader，根据双亲委托机制，其父类加载器加载不了，就由loader3自己加载，此时命名空间以loader3为准。所以它加载类和前面两个不一样，也就是说相同类被重新加载了一次。

![[Pasted image 20231102145755.png|550]]

### 规则

* 子加载器所加载的类能够访问父加载器所加载的类。
* 父类加载器所加载的类无法访问到子类加载器所加载的类。

#### 依赖类由相同类加载器加载

>当然依赖的类肯定要在同一个类加载器支持的路径下，比如String类在rt.jar，MySample类中主动引用String类时，也不会由AppClassLoader加载~

```java
public class MySample {
    public MySample() {
        System.out.println("MySample is loaded by: " + this.getClass().getClassLoader());
        new MyCat();
    }
}
```

```java
public class MyCat {  
    public MyCat() {  
        System.out.println("MyCat is loaded by: " + this.getClass().getClassLoader());  
    }  
}
```

```java
public class Test111 {  
  
    public static void main(String[] args) throws Exception {  
        String classPath = "D:\\";  
        String className = "com.westboy.base.jvm.book.classloader.MySample";  
  
        // 使用上述自定义类加载器加载类  
        MyClassLoader loader1 = new MyClassLoader("loader1");  
        loader1.setPath(classPath);  
  
        Class<?> clazz = loader1.loadClass(className);  
        System.out.println("class: " + clazz.hashCode());  
  
        // 如果注释掉该行，那么并不会实例化MySample对象，即MySample构造方法不会被调用  
        // 因此不会实例化MyCat对象，即没有对MyCat进行主动使用，这里就不会加载MyCat类  
        Object object = clazz.newInstance();  
    }  
}
```

执行结果：

```
class: 1163157884
MySample is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2
MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2
```

#### 子可访问父

>重新编译后，将当前路径下的MySample.class剪切到指定目录下，注意是剪切，意味着当前路径不存在MySample.class，否则MySample.class就不会被loader1加载~

```java
public class Test111 {  
  
    public static void main(String[] args) throws Exception {  
        String classPath = "D:\\";  
        String className = "com.westboy.base.jvm.book.classloader.MySample";  
  
        // 使用上述自定义类加载器加载类  
        MyClassLoader loader1 = new MyClassLoader("loader1");  
        loader1.setPath(classPath);  
  
        Class<?> clazz = loader1.loadClass(className);  
        System.out.println("class: " + clazz.hashCode());  
  
        // 如果注释掉该行，那么并不会实例化MySample对象，即MySample构造方法不会被调用  
        // 因此不会实例化MyCat对象，即没有对MyCat进行主动使用，这里就不会加载MyCat类  
        Object object = clazz.newInstance();  
    }  
}
```

类加载情况：

![[Pasted image 20231103165327.png|700]]

执行结果：

```
findClass invoked: com.westboy.base.jvm.book.classloader.MySample
class loader name: loader1
class: 356573597
MySample is loaded by: ClassLoaderName: loader1
MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2
```

#### 父不可访问子

>重新编译后，将当前路径下的MyCat.class剪切到指定目录下，注意是剪切，意味着当前路径不存在MyCat.class，否则MyCat.class就不会被loader1加载~

```java
public class Test111 {  
  
    public static void main(String[] args) throws Exception {  
        String classPath = "D:\\";  
        String className = "com.westboy.base.jvm.book.classloader.MySample";  
  
        // 使用上述自定义类加载器加载类  
        MyClassLoader loader1 = new MyClassLoader("loader1");  
        loader1.setPath(classPath);  
  
        Class<?> clazz = loader1.loadClass(className);  
        System.out.println("class: " + clazz.hashCode());  
  
        // 如果注释掉该行，那么并不会实例化MySample对象，即MySample构造方法不会被调用  
        // 因此不会实例化MyCat对象，即没有对MyCat进行主动使用，这里就不会加载MyCat类  
        Object object = clazz.newInstance();  
    }  
}
```

类加载情况：

![[Pasted image 20231103170230.png|700]]

执行结果：

```
class: 1163157884
MySample is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2
Exception in thread "main" java.lang.NoClassDefFoundError: com/westboy/base/jvm/book/classloader/MyCat
	at com.westboy.base.jvm.book.classloader.MySample.<init>(MySample.java:7)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at java.lang.Class.newInstance(Class.java:442)
	at com.westboy.base.jvm.book.classloader.Test111.main(Test111.java:17)
Caused by: java.lang.ClassNotFoundException: com.westboy.base.jvm.book.classloader.MyCat
	at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	... 7 more
```

## 当前线程上下文类加载器

重要性

默认现成上下文类加载器就是APPClassLoader，为什么呢？

查看`sun.misc.Launcher`源码：

>`sun.misc.Launcher`是JVM的启动类，它扮演了JVM启动的关键角色。这个类的主要作用是负责启动Java程序并加载主类（包含`public static void main(args)`方法的类）。

![[Pasted image 20231102165510.png|600]]

### JDBC

#### 原生JDBC流程

JDBC示例

```java
public class JdbcTest {  
    public static void main(String[] args) throws SQLException {  
        String DB_URL = "jdbc:mysql://10.2.6.43:3306/test?characterEncoding=utf8&allowMultiQueries=true&serverTimezone=Asia/Shanghai";  
        String USER = "user";  
        String PASS = "Lachesis-mh_1024";  
        // Class.forName("com.mysql.cj.jdbc.Driver");  
        Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);  
        Statement stmt = conn.createStatement();  
        ResultSet rs = stmt.executeQuery("SELECT id, username, age, birth_date, create_time, update_time FROM user_info WHERE id = 1");  
        while (rs.next()) {  
            int id = rs.getInt(1);  
            String username = rs.getString(2);  
            int age = rs.getInt(3);  
            Date birthDate = rs.getDate(4);  
            long createTime = rs.getLong(5);  
            long updateTime = rs.getLong(6);  
  
            System.out.println(id);  
            System.out.println(username);  
            System.out.println(age);  
            System.out.println(birthDate);  
            System.out.println(createTime);  
            System.out.println(updateTime);  
        }  
    }  
}
```

早前使用JDBC时都要写Class.forName("com.mysql.cj.jdbc.Driver")，为什么现在不用写了呢？

>看网上说是JDBC 4.0之后就不用了~

因为使用了<font color="#f79646">SPI机制</font>，由ServiceLoader加载com.mysql.cj.jdbc.Driver，  ServiceLoader帮我们执行了Class.forName("com.mysql.cj.jdbc.Driver")，触发类加载流程，执行Driver的类初始化。

![[Pasted image 20231108090710.png]]

#### SpringBoot场景流程

==当SpringBoot+MyBatis+HikariPool+MySQL时，com.mysql.cj.jdbc.Driver的加载并不是由SPI机制加载的~==

而在调用com.zaxxer.hikari.HikariConfig#setDriverClassName方法时加载的，其核心代码如下：

```java
// 删除了一些日志和异常代码~
public void setDriverClassName(String driverClassName) {  
    Class<?> driverClass = null;  
    ClassLoader threadContextClassLoader = Thread.currentThread().getContextClassLoader();  
    try {  
        if (threadContextClassLoader != null) {  
            driverClass = threadContextClassLoader.loadClass(driverClassName);  
        }  
        if (driverClass == null) {  
            driverClass = this.getClass().getClassLoader().loadClass(driverClassName);  
        }  
    } catch (ClassNotFoundException e) {  
    }  
  
    if (driverClass == null) {  
        throw new RuntimeException("Failed to load driver class " + driverClassName + " in either of HikariConfig class loader or Thread context classloader");  
    }  
  
    try {  
        driverClass.newInstance();  
        this.driverClassName = driverClassName;  
    } catch (Exception e) {  
        throw new RuntimeException("Failed to instantiate class " + driverClassName, e);  
    }  
}
```

通过在java.sql.DriverManager#registerDriver方法中打断点后，然后利用IDEA的【表达式求值功能】输出执行到当前断点的链路信息：

![[Pasted image 20231103105719.png|650]]

链路信息：

![[Pasted image 20231103104936.png|900]]

通过打断点进行验证：

![[Pasted image 20231103110321.png|1000]]

#### 引申出的核心问题（TODO）

其实不管是原生JDBC流程还是SpringBoot&HikariPool流程，最终都是通过Class#forName触发com.mysql.cj.jdbc.Driver加载，连接并初始化。

<font color="#f79646">那么现在最核心的问题是由BootstrapClassLoader加载的java.sql.DriverManager类在执行getConnection方法时，为什么可以调用由AppClassLoader加载的com.mysql.cj.jdbc.Driver的connec方法呢？</font>

<font color="#4bacc6">当前线程上下文类加载器工作原理是？</font>

## 开源组件类加载机制

### Tomcat

TODO
### SpringBoot

TODO
### ByteBuddy

TODO
### SkyWalking












