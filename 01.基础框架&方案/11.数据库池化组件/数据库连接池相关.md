# 服务端

>[!important] [[MySQL_连接相关知识点]]

# 连接查询

默认项目启动阶段，没有对数据库进行操作的话，就不会进行数据库连接池初始化，即延迟初始化。

```sql
Server version: 5.6.51-log MySQL Community Server (GPL) -- 注意此处的MySQL版本

mysql> show variables like '%timeout%';
+-----------------------------+----------+
| Variable_name               | Value    |
+-----------------------------+----------+
| connect_timeout             | 10       | -- 这里的单位统统都是秒
| delayed_insert_timeout      | 300      |
| innodb_flush_log_at_timeout | 1        |
| innodb_lock_wait_timeout    | 50       |
| innodb_rollback_on_timeout  | ON       |
| interactive_timeout         | 1800     |
| lock_wait_timeout           | 1800     |
| net_read_timeout            | 30       |
| net_write_timeout           | 60       |
| rpl_stop_slave_timeout      | 31536000 |
| slave_net_timeout           | 3600     |
| wait_timeout                | 1800     | -- 1800s=30min，其含义为一个连接在空闲等待多长时间就会断开这个连接
+-----------------------------+----------+
```

## 服务端查询


```sql
-- 查看空闲连接
select * from information_schema.processlist where command = 'Sleep';
```

| ID | USER | HOST | DB | COMMAND | TIME | STATE | INFO |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 409939 | user | 10.2.3.170:45964 | windranger\_foundation | Sleep | 810 |  | null |
| 409795 | user | 10.2.3.170:41456 | windranger\_auth | Sleep | 1403 |  | null |
| 409742 | user | 10.2.3.170:33684 | windranger\_emr | Sleep | 1581 |  | null |
| 409923 | user | 10.2.3.170:41558 | windranger\_auth | Sleep | 915 |  | null |
| 409985 | user | 10.2.3.170:52680 | windranger\_pharmaux | Sleep | 655 |  | null |
| 409853 | user | 10.2.3.170:47300 | windranger\_hospital | Sleep | 1291 |  | null |
| 409711 | user | 10.2.3.170:56602 | windranger\_foundation | Sleep | 1715 |  | null |

其中，TIME单位是秒！

## 客户端查询


### HikariCP

一般我们都会使用数据库连接池，比如HikariCP，这里借助Arthas工具进行查看。

```sh
# 这里是多数据源的情况，所以会有多个连接池
[arthas@22932]$ vmtool --action getInstances --className com.zaxxer.hikari.HikariDataSource
@HikariDataSource[][
    @HikariDataSource[HikariDataSource (HikariPool-4)],
    @HikariDataSource[HikariDataSource (HikariPool-2)],
    @HikariDataSource[HikariDataSource (HikariPool-1)],
    @HikariDataSource[HikariDataSource (HikariPool-3)],
]
```

```java
 poolStatus.put("active", pool.getActiveConnections());  
 poolStatus.put("idle", pool.getIdleConnections());  
 poolStatus.put("total", pool.getTotalConnections());  
 poolStatus.put("awaiting", pool.getThreadsAwaitingConnection());  
```


```sh
# 当前活跃连接数
vmtool --action getInstances --className com.zaxxer.hikari.HikariDataSource --express 'instances[1].pool.getActiveConnections()'
# 当前空闲连接数，由于调用此方法和getActiveConnections()之间的时间差异，空闲连接数加活动连接数的总和可能小于或大于getTotalConnections()返回的值
vmtool --action getInstances --className com.zaxxer.hikari.HikariDataSource --express 'instances[1].pool.getIdleConnections()'
# 当前连接池总共创建的连接
vmtool --action getInstances --className com.zaxxer.hikari.HikariDataSource --express 'instances[1].pool.getTotalConnections()'
# 当前等待获取数据库连接的线程数量
vmtool --action getInstances --className com.zaxxer.hikari.HikariDataSource --express 'instances[1].pool.getThreadsAwaitingConnection()'
```


### Druid

# 超时问题

|                                  | 配置                                      | 默认                                           |
| -------------------------------- | --------------------------------------- | -------------------------------------------- |
| JDBC Driver Level Socket Timeout | 在jdbc-url后新增配置&socketTimeout=300000<br> | 单位是<font color="#f79646">毫秒</font>，默认0，即永不超时 |
| JDBC Statement Level Timeout     | java.sql.Statement#setQueryTimeout      | 单位是<font color="#f79646">秒</font>，默认0，即永不超时  |

首先说下JDBC Statement是什么？在JDBC中，Statement是一个接口，用于执行SQL查询或更新数据库的操作。

- JDBC Statement Level Timeout：即每个Statement执行超时时间。每个Statement都可以设置自己的timeout时间。
- JDBC Driver Level Socket Timeout：应用服务使用JDBC与数据库建立连接时，底层是通过socket与数据库建立连接并通信，数据库并不对连接超时进行处理，JDBC Socket Timeout在数据库被突然宕机或是发生网络错误（由于设备故障等原因）时十分重要。由于TCP/IP的原因，应用服务的socket没有办法探测到网络错误，因此应用服务也无法主动发现数据库连接断开。如果没有设置JDBC Socket Timeout的话，应用服务会无限期等下去，这种连接也被称作dead connection。为了避免此情况发生，设置JDBC Socket Timeout变得十分重要。不同JDBC驱动的配置方式不同。

>对于后者补充一点，应该不会无限期等待下去，还有一个操作系统的TCP超时（通常为10分钟）

注意：JDBC Statement Level Timeout是无法处理网络失败时的超时，它能做到的仅仅是限制Statement的操作时间。网络连接失败时的超时时间必须交由JDBC来处理。

>ChatGPT的回答，<font color="#f79646">待验证</font>

* JDBC Statement Level Timeout：
    - 作用范围：适用于单个SQL语句的执行。
    - 设置方式：通过`setQueryTimeout(int seconds)`方法设置，单位为秒。
    - 效果：当执行SQL语句的时间超过设置的超时时间时，该语句的执行将被取消，并且Statement和Connection仍然可以继续使用。
    - 影响范围：只会影响当前执行的SQL语句。
* JDBC Driver Level Socket Timeout：
    - 作用范围：适用于整个JDBC驱动程序的连接。
    - 设置方式：通过`setNetworkTimeout(Executor executor, int milliseconds)`方法设置，单位为毫秒。
    - 效果：当超过设置的超时时间后，JDBC 驱动程序将关闭连接并释放相关资源。
    - 影响范围：会影响整个JDBC驱动程序的连接，在网络超时前，如果查询超时，则仅取消当前执行的SQL语句，连接仍然可用；如果网络超时或由于网络问题导致语句超时失败，则连接会被标记为已关闭。

# JdbcTemplate

>JdbcTemplate本身并不包含连接池功能

>如何整合数据库连接池呢？

```java
@Configuration
public class Config {

    @Bean
    public DataSource dataSource() {
        HikariConfig hikariConfig = new HikariConfig();
        hikariConfig.setJdbcUrl("jdbc:mysql://localhost:3306/mydatabase");
        hikariConfig.setUsername("username");
        hikariConfig.setPassword("password");

        return new HikariDataSource(hikariConfig);
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

# Spring+MyBatis+HikariCP


* [全面讲解HikariCP的使用和源码](https://www.cnblogs.com/ZhangZiSheng001/p/12329937.html)

>Spring+MyBatis时，是如何与数据库连接池整合的？

```java
@Configuration
public class MyBatisConfig {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        sqlSessionFactoryBean.setMapperLocations(resolver.getResources("classpath:/mybatis/mappers/*.xml"));
        return sqlSessionFactoryBean.getObject();
    }
}
```

>思考：JdbcTemplate+DataSource从功能层面比较的有些类似Spring+MyBatis+DataSource



# 生产场景问题

## 1.获取不到连接/获取连接超时

*异常现象*

```
com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 60000, active 20, maxActive 20, creating 0
```

活动的连接数与最大连接数相同，**连接用完了，在等待（我写的配置是60000毫秒即60秒）新的连接，却没有新连接可用**，然后超时了。

*常见的原因*

---

 **1. SQL执行太慢（数据库性能瓶颈） —— 最高概率**

表现：

- active=50长时间不下降
- DB CPU高
- 某些SQL执行时间 > 数秒甚至锁住
    
排查：

1. 查数据库慢查询：`show full processlist`
2. 查是否有锁表：`show engine innodb status`
3. 分析慢日志：是否有 `SELECT ... WHERE ...` 未加索引
4. 重点关注大表扫描、order by、group by、join

---

 **2. 代码未正确关闭连接（高频问题）**

极易导致连接被占满。

表现：

- 应用重启后变正常
- active数缓慢增长不下降

排查：

在代码中确保：

```java
try {
    ...
} finally {
    if (rs != null) rs.close();
    if (ps != null) ps.close();
    if (conn != null) conn.close();
}
```

如果是MyBatis通常没问题，但Mapper中使用了**自定义JDBC**很容易忘关。

---

 **3. 某接口并发量过大 → 瞬时压满连接池**

表现：

- 压测或业务瞬时峰值时必现
- active=50波动明显

排查：
- 看access log、网关统计QPS
- 看这个接口是否执行多次DB访问
- 特别是内部循环里查询DB的写法

解决：

- 加缓存
- 批处理
- 限流
- 减少数据库round trip

---

**4. 连接泄漏（Druid未检测到的死连接）**

表现：

- druid 统计中 active 长时间不下降
- creating=0（因为池认为连接都健康）

排查：

* 开：`druid.remove-abandoned=true` 和 `druid.remove-abandoned-timeout=180`
* 并在日志中查看是否有：`Connection Leak Detection`

---

**5. 数据库网络问题导致连接无法创建**

表现：

- 数据库偶发不可达
- Druid creating=0
- 日志中可能伴随：`Communications link failure`

排查：

- ping/telnet 数据库端口
- 查看Linux网络异常：dmesg是否有`Connection reset`

---

**6. Druid配置不合理（maxActive太小/testOnBorrow false）**

表现：

- 日常QPS不高也会偶发
- 连接池内有“僵尸连接”

建议配置： `maxActive=200`，根据业务适当调大 







