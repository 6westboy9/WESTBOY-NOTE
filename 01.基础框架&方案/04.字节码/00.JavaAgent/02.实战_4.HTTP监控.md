
# 需求说明

通过JavaAgent监控HTTP客户端和服务端的监控。首先这个问题，得拆成两部分看：
* 被监控应用<font color="#e36c09">作为HTTP客户端</font>，发起向服务端的调用请求。[[#客户端监控]]
* 被监控应用<font color="#e36c09">作为HTTP服务端（在本文其实主要是对HttpServlet的监控）</font>，响应来自客户端的请求。[[#服务端监控]]

>项目源码参见：https://github.com/6westboy9/learn-center/tree/main/basis-javaagent

# 客户端监控

当前应用作为客户端发起HTTP调用，对该调用进行监控。

## 1.注册监控组件

核心实现：

```java

```

## 2.监控组件实现


```java

```


# 服务端监控

当前应用作为HTTP的服务端，进行客户端的请求处理并响应结果，对其进行监控。

在使用SpringBoot+Tomcat服务中，需要监控的核心实现类是`javax.servlet.http.HttpServlet`，因为最终HTTP请求都是通过该组件完成请求与响应处理。

## 1.注册监控组件

代码结构：

```sh
base-javaagent
└── src.main.java
	└── com.lachesis.base.javaagent
		├── http
		│	└── HttpCollector.java              # 核心组件
		│   ├── HttpInfo.java                   
		│   ├── HttpServletRequestAdapter.java   
		│   └── HttpServletResponseAdapter.java
		└── agent
			└── MyJavaAgent.java
```

```java
public class MyJavaAgent {  
    public static void premain(String agentOps, Instrumentation instrumentation) {
		instrumentation.addTransformer(new HttpCollector());     
    }  
}
```

打包插件：
```xml
<build>
    <plugins>
        <plugin>
            <artifactId>maven-assembly-plugin</artifactId>
            <configuration>
                <!-- 把依赖的jar包一起打包 -->
                <descriptorRefs>
                    <descriptorRef>jar-with-dependencies</descriptorRef>
                </descriptorRefs>
                <archive>
                    <!-- 注册premain的class -->
                    <manifestEntries>
                        <Premain-Class>com.lachesis.base.javaagent.agent.MyJavaAgent</Premain-Class>
                    </manifestEntries>
                </archive>
            </configuration>
            <executions>
                <execution>
                    <id>make-assembly</id>
                    <phase>package</phase>
                    <goals>
                        <goal>single</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```
## 2.监控组件实现

核心组件`HttpCollector`的代码实现：
```java
public class HttpCollector implements ClassFileTransformer {  
  
    private static final String TARGET_CLASS = "javax.servlet.http.HttpServlet";  
    private static final String TARGET_METHOD = "service";  
    private static final String SOURCE_CODE_TEMPLATE = ""  
        + "{\n"  
        + "    %s\n"  
        + "    try {\n"  
        + "        %s$agent($$);\n"  
        + "    } catch (Throwable e) {\n"  
        + "        %s\n"  
        + "        throw e;\n"  
        + "    } finally {\n"  
        + "        %s\n"  
        + "    }\n"  
        + "}\n";  
  
    @Override  
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {  
        if (!TARGET_CLASS.replaceAll("\\.", "/").equals(className)) {  
            return null;  
        }  
        try {  
            return buildClass(loader);  
        } catch (Exception e) {  
            e.printStackTrace();  
            throw new RuntimeException(e);  
        }  
    }  
  
    public byte[] buildClass(ClassLoader loader) throws Exception {  
        ClassPool pool = new ClassPool();  
        pool.insertClassPath(new LoaderClassPath(loader));  
        CtClass ctClass = pool.get(TARGET_CLASS);  
        CtMethod oldMethod = ctClass.getDeclaredMethod(TARGET_METHOD);  
        // 复制后的service方法  
        CtMethod newMethod = CtNewMethod.copy(oldMethod, ctClass, null);  
        // 复制前的service方法重名为service$agent  
        oldMethod.setName(oldMethod.getName() + "$agent");  
        String beginSrc = String.format("%s httpInfo = %s.begin($args);", HttpInfo.class.getName(), HttpCollector.class.getName());  
        String errorSrc = String.format("%s.error(e, httpInfo);", HttpCollector.class.getName());  
        String endSrc = String.format("%s.end(httpInfo, $args);", HttpCollector.class.getName());  
        // 复制后的service方法修改  
        newMethod.setBody(String.format(SOURCE_CODE_TEMPLATE, beginSrc, TARGET_METHOD, errorSrc, endSrc));  
        ctClass.addMethod(newMethod);  
        return ctClass.toBytecode();  
    }  
  
    public static HttpInfo begin(Object[] args) {  
        HttpInfo httpInfo = new HttpInfo();  
        httpInfo.setBeginTime(System.currentTimeMillis());  
        // HttpServletRequest适配器解析请求信息  
        HttpServletRequestAdapter adapter = new HttpServletRequestAdapter(args[0]);  
        httpInfo.setRequestUrl(adapter.getRequestURL());  
        httpInfo.setClientIp(adapter.getClientIp());  
        httpInfo.setMethod(adapter.getMethod());  
        return httpInfo;  
    }  
  
    public static void end(HttpInfo httpInfo, Object[] args) {  
        httpInfo.setEndTime(System.currentTimeMillis());  
        long useTime = httpInfo.getEndTime() - httpInfo.getBeginTime();  
        httpInfo.setUseTime(useTime);  
        // HttpServletResponse适配器解析响应信息  
        HttpServletResponseAdapter adapter = new HttpServletResponseAdapter(args[1]);  
        httpInfo.setResponseStatus(adapter.getStatus());  
        System.out.println("========> " + httpInfo);  
    }  
  
    public static void error(Throwable error, HttpInfo httpInfo) {  
        httpInfo.setErrorMessage(error.getMessage());  
        System.out.println("========> " + httpInfo);  
    }  
}
```

新增`service$agent`方法的核心实现：
```java
{
    com.lachesis.base.javaagent.agent.http.HttpInfo httpInfo = com.lachesis.base.javaagent.agent.http.HttpCollector.begin($args);
    try {
        service$agent($$);
    } catch (Throwable e) {
        com.lachesis.base.javaagent.agent.http.HttpCollector.error(e,httpInfo);
        throw e;
    } finally {
        com.lachesis.base.javaagent.agent.http.HttpCollector.end(httpInfo,$args);
    }
}
```

## 3.原理

![[Pasted image 20231024123937.png|650]]

>其实这里的原理跟[[02.实战_1.业务监控#4.实现原理]]是一模一样的~

<font color="#f79646">借助Arthas工具反编译验证</font>

其中，上述代码的作用先将原生的`service`方法复制了一份，重命名为`service$agent`：

![[Pasted image 20231024121943.png|900]]

原生的`service`方法改为调用`service$agent`方法，从而实现对HTTP请求的监控。

![[Pasted image 20231024122256.png|900]]

## 4.测试

1.SpringBoot起一个HTTP应用，提供一个简单的接口。
```java
@RestController  
@RequestMapping("/demo")  
public class DemoController {  
    @PostMapping("/demo01")  
    public String demo01(@RequestBody Demo01Request request) {
	    JSONObject result = new JSONObject();
        result.set("message", request.getMessage());  
        result.set("info", "hello");  
        return JSONUtil.toJsonStr(result); 
    }  
}
```

2.通过JavaAgent启动时加载。
```
-javaagent:D:\IdeaProjects\mine\westboy-hub\base-javaagent\target\base-javaagent-1.0-SNAPSHOT-jar-with-dependencies.jar
```

3.使用第三方HTTP客户端发起对调用，观察监控日志。
```
========> {"clientIp":"127.0.0.1","requestUrl":"http://localhost:8491/boot/demo/demo01","method":"POST","responseStatus":200,"beginTime":1698118594624,"endTime":1698118594828,"useTime":204}
```

