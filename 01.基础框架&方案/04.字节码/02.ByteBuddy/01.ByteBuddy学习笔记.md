
# 1.生成一个类

## subclass默认命名策略

```java
public class ByteBuddyTest {  
  
    private String path;  
  
	@BeforeEach  
	public void init() {  
	    path = ByteBuddyTest.class.getClassLoader().getResource("").getPath();  
	    // path = /D:/IdeaProjects/mine/bytebuddy-demo/bytebuddy-test/target/test-classes/ 
	    System.out.println("path = " + path);  
	}
	
	@Test
    public void test1() throws Exception {  
		// 表示生成的字节码还未加载到JVM中  
		DynamicType.Unloaded<Object> unloaded = new ByteBuddy()  
		    // 指定父类  
		    .subclass(Object.class)  
		    .make();  
		// 获取生成类的字节码  
		byte[] bytes = unloaded.getBytes();  
		// 将生成类的字节码保存到指定目录  
		unloaded.saveIn(new File(path));
    }  
}
```

查看生成的类路径：

![[Pasted image 20231106153200.png|400]]

查看生成的类反编译结果：

```java
package net.bytebuddy.renamed.java.lang;  
  
public class Object$ByteBuddy$k4gw29fj {  
    public Object$ByteBuddy$k4gw29fj() {  
    }  
}
```

将父类换成我们自己新增的UserService类：

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.subclass(UserManager.class)
	.make();
unloaded.saveIn(new File(path));
```

查看生成的类反编译结果：

```java
package com.roadjava.bytebuddy;  
  
public class UserManager$ByteBuddy$HllgJWkl extends UserManager {  
    public UserManager$ByteBuddy$HllgJWkl() {  
    }  
}
```


默认生成的类的命名规则（即不指定命名策略的情况下）：

* 对于父类是JDK自带的类的名称：`net.bytebuddy.renamed.java.lang.Object$ByteBuddy$k4gw29fj`
* 对于父类非JDK自带的类的名称：`com.roadjava.bytebuddy.UserManager$ByteBuddy$HllgJWkl`

## subclass指定命名策略

```java
NamingStrategy.SuffixingRandom suffixingRandom = new NamingStrategy.SuffixingRandom("rjava");  
// 表示生成的字节码还未加载到JVM中  
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()  
	.with(suffixingRandom)  
	// 指定父类  
	.subclass(UserManager.class)  
	.make();
```

修改后执行：

```java
package com.roadjava.bytebuddy;  
  
public class UserManager$rjava$Lgl3A079 extends UserManager {  
    public UserManager$rjava$Lgl3A079() {  
    }  
}
```

## subclass指定具体类名

```java
NamingStrategy.SuffixingRandom suffixingRandom = new NamingStrategy.SuffixingRandom("rjava");  
// 表示生成的字节码还未加载到JVM中
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()  
	.with(suffixingRandom)  
	// 指定父类  
	.subclass(UserManager.class)  
	.name("a.b.SubUserService")  // suffixingRandom将不再生效~
	.make();
```

注意：<font color="#f79646">类名肯定是符合Java语言规范的</font>，不然就会报错：

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()  
	.with(suffixingRandom)  
	// 指定父类  
	.subclass(UserManager.class)  
	.name("a.b.1SubUserService")  // 指定类名以数字开头
	.make();
```

执行报错：

```
Exception in thread "main" java.lang.IllegalStateException: Illegal type name: a.b.1SubUserService for class a.b.1SubUserService
```

这个校验过程在会消耗性能，可以通过配置修改策略。

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()  
        .with(suffixingRandom)  
        .with(TypeValidation.of(false))  // 不进行校验
        // 指定父类  
        .subclass(UserManager.class)  
        .name("a.b.1SubUserService")  
        .make();
```

可以执行成功，但是没有意义的，了解内容~

## 接将生成的字节码写入指定文件

```java
// 表示生成的字节码还未加载到JVM中
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()  
	// 指定父类  
	.subclass(UserManager.class)  
	.name("a.b.SubUserService1")  
	.make();  
// 获取生成类的字节码  
byte[] bytes = unloaded.getBytes();  
FileUtil.writeBytes(bytes, new File(path  
	+ FileUtil.FILE_SEPARATOR + "a"  
	+ FileUtil.FILE_SEPARATOR + "b"  
	+ FileUtil.FILE_SEPARATOR + "SubUserService1.class"));  
```

查看生成的类反编译结果：

```java
package a.b;

import com.learn.basis.bytebuddy.UserService;

public class SubUserService1 extends UserService {
    public SubUserService1() {
    }
}
```

## 将生成的字节码注入到jar包

```java
String injectJarPath = "D:\\IdeaProjects\\mine\\learn-center\\boot-web\\target\\boot-web.jar";  
unloaded.inject(new File(injectJarPath));
```

打开boot-web.jar包查看：

![[Pasted image 20231103003012.png|300]]

![[Pasted image 20231103003043.png|300]]

# 2.对实例方法插桩

```java
@Test  
public void test2() throws Exception {  
    DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()  
        .subclass(UserManager.class)  
        .name("a.b.SubObj")  
        // named通过名字指定要拦截的方法  
        .method(named("toString"))  
        // 指定拦截到方法后该如何处理  
        .intercept(FixedValue.value("hello bytebuddy"))  
        .make();  
    // Loaded表示生成的字节码已经被加载到jvm  
    DynamicType.Loaded<UserManager> loaded = unloaded.load(getClass().getClassLoader());  
    // 获取到Class对象  
    Class<? extends UserManager> loadedClass = loaded.getLoaded();  
    UserManager userManager = loadedClass.newInstance();  
    String toStringResult = userManager.toString();  
    // loadedClass.getClassLoader() = net.bytebuddy.dynamic.loading.ByteArrayClassLoader@4d5d943d  
    System.out.println("loadedClass.getClassLoader() = " + loadedClass.getClassLoader());  
    // toStringResult = hello bytebuddy  
    System.out.println("toStringResult = " + toStringResult);  
    // Loaded同样有saveIn、getBytes、inject方法,和Unloaded继承自DynamicType  
    loaded.saveIn(new File(path));  
}
```

输出结果：

```
path = /D:/IdeaProjects/mine/bytebuddy-demo/bytebuddy-test/target/test-classes/
UserManager的构造方法
loadedClass.getClassLoader() = net.bytebuddy.dynamic.loading.ByteArrayClassLoader@74f0ea28
toStringResult = hello bytebuddy
```

最终生成的字节码反编译后：

```java
package a.b;  
  
import com.roadjava.bytebuddy.UserManager;  
  
public class SubObj extends UserManager {  
    public String toString() {  
        return "hello bytebuddy";  
    }  
  
    public SubObj() {  
    }  
}
```

# 3.动态增强的三种方式

## subclass

==增强前==

```java
public class UserManager {

    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long id) {
        return "用户id:"+ id +"的名字:" + UUID.randomUUID().toString();
    }
    
    public void print() {
        System.out.println(1);
    }
    
    public int selectAge() {
        return 33;
    }
}
```

==实现==

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.subclass(UserManager.class)
	.name("a.b.SubObj")
	// 指定方法名称
	.method(named("selectUserName").and(
		// 指定返回类型
		returns(TypeDescription.CLASS)
		.or(returns(TypeDescription.OBJECT))
		.or(returns(TypeDescription.STRING))
	))
	.intercept(FixedValue.nullValue())
	.make();
unloaded.saveIn(new File(path));
```

==增强后反编译结果==

```java
package a.b;

import com.roadjava.bytebuddy.UserManager;

public class SubObj extends UserManager {
    public String selectUserName(Long var1) {
        return null;
    }

    public SubObj() {
    }
}
```
## rebase&多个方法同时增强

```java
public class UserManager {

    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long id) {
        return "用户id:"+ id +"的名字:" + UUID.randomUUID().toString();
    }
    
    public void print() {
        System.out.println(1);
    }
    
    public int selectAge() {
        return 33;
    }
}
```

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.rebase(UserManager.class)
	.method(named("selectUserName").and(
		returns(TypeDescription.CLASS)
			.or(returns(TypeDescription.OBJECT))
			.or(returns(TypeDescription.STRING))
	))
	.intercept(FixedValue.nullValue())
	.method(named("print").and(
		returns(TypeDescription.VOID)
	))
	.intercept(FixedValue.value(TypeDescription.VOID))
	.method(named("selectAge"))
	.intercept(FixedValue.value(0))
	.make();
unloaded.saveIn(new File(path));
```

==反编译后==

```java
package com.roadjava.bytebuddy;

public class UserManager {
    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long var1) {
        return null;
    }

    public void print() {
        Class var10000 = Void.TYPE;
    }

    public int selectAge() {
        return 0;
    }
}
```

借助工具查看字节码

![[Pasted image 20231106122918.png|700]]

## redefine

比较简单只是，将上面的rebase方法改为redefine即可。

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.redefine(UserManager.class) // 只需改这里
	.method(named("selectUserName").and(
		returns(TypeDescription.CLASS)
			.or(returns(TypeDescription.OBJECT))
			.or(returns(TypeDescription.STRING))
	))
	.intercept(FixedValue.nullValue())
	.method(named("print").and(
		returns(TypeDescription.VOID)
	))
	.intercept(FixedValue.value(TypeDescription.VOID))
	.method(named("selectAge"))
	.intercept(FixedValue.value(0))
	.make();
unloaded.saveIn(new File(path));
```

## 小结


| 方式     | 区别                                                                                 |
| -------- | ------------------------------------------------------------------------------------ |
| subclass | 创建子类的方式                                                         |
| rebase   | 基于目标类的方法进行拦截，将拦截方法覆盖，原方法保留并重命名为`原始方法$original$随机字符串` |
| redefine  | 与rebase比较类似，不同的是原方法不再保留  |

# 4.插入新的方法

==插入前==

```java
public class UserManager {

    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long id) {
        return "用户id:"+ id +"的名字:" + UUID.randomUUID().toString();
    }
    public void print() {
        System.out.println(1);
    }
    public int selectAge() {
        return 33;
    }
}
```

==插入实现==

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.redefine(UserManager.class)
	// 定义方法的名字,返回值,修饰符
	.defineMethod("selectUserName2", String.class, Modifier.PUBLIC + Modifier.STATIC)
	// 指定方法的参数
	.withParameter(String[].class, "args")
	// 指定拦截到方法后该如何处理
	.intercept(FixedValue.value("bytebuddy 生成的新方法"))
	.make();
unloaded.saveIn(new File(path));
```

==插入后反编译结果==

```java
package com.roadjava.bytebuddy;

import java.util.UUID;

public class UserManager {
    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long id) {
        return "用户id:" + id + "的名字:" + UUID.randomUUID().toString();
    }

    public void print() {
        System.out.println(1);
    }

    public int selectAge() {
        return 33;
    }

    public static String selectUserName2(String[] args) {
        return "bytebuddy 生成的新方法";
    }
}
```

# 5.插入新属性

==插入前==

```java
public class UserManager {  
  
    public UserManager() {  
        System.out.println("UserManager的构造方法");  
    }  
  
    public String selectUserName(Long id) {  
        return "用户id:"+ id +"的名字:" + UUID.randomUUID().toString();  
    }  
  
    public void print() {  
        System.out.println(1);  
    }  
  
    public int selectAge() {  
        return 33;  
    }  
}
```

==插入实现==

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.redefine(UserManager.class)
	.name("a.b.SubObj")
	// 定义属性（属性名称可以与setXXX/getXXX不同名）
	.defineField("param", int.class, Modifier.PRIVATE)
	// 指定age的getter和setter所在的接口
	.implement(UserAgeInterface.class)
	// 生成接口实现
	.intercept(FieldAccessor.ofField("param"))
	.make();
unloaded.saveIn(new File(path));
```

新增接口和方法

```java
public interface UserAgeInterface {
    void setAge(int age);
    int getAge();
}
```

==插入后反编译结果==

```java
package a.b;  
  
import com.roadjava.bytebuddy.UserAgeInterface;  
import java.util.UUID;  
  
public class SubObj implements UserAgeInterface {  
    private int param;  
  
    public SubObj() {  
        System.out.println("UserManager的构造方法");  
    }  
  
    public String selectUserName(Long id) {  
        return "用户id:" + id + "的名字:" + UUID.randomUUID().toString();  
    }  
  
    public void print() {  
        System.out.println(1);  
    }  
  
    public int selectAge() {  
        return 33;  
    }  
  
    public void setAge(int var1) {  
        this.param = var1;  
    }  
  
    public int getAge() {  
        return this.param;  
    }  
}
```


# 6.方法委托

前面所讲的拦截到目标方法后，进行增强的拦截器都是ByteBuddy提供的，那么如果我们需要自定义呢？这里的方法委托就是实现此需求。

## 委托给同名静态方法


```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.subclass(UserManager.class)
	.name("a.b.SubObj")
	.method(named("selectUserName"))
	// 委托给UserManagerInterceptor1中与被拦截方法同签名的静态方法
	.intercept(MethodDelegation.to(UserManagerInterceptor1.class))
	.make();

DynamicType.Loaded<UserManager> loaded = unloaded.load(getClass().getClassLoader());
Class<? extends UserManager> loadedClass = loaded.getLoaded();
UserManager userManager = loadedClass.newInstance();
String result = userManager.selectUserName(100L);
System.out.println("result = " + result);
unloaded.saveIn(new File(path));
```

```java
public class UserManagerInterceptor1 {
	// 注意必须为静态同名方法
    public static String selectUserName(Long id) {
        return "UserManagerInterceptor1用户id:"+ id +"的名字:" + UUID.randomUUID().toString();
    }
}
```

==输出结果==

```
UserManager的构造方法
result = UserManagerInterceptor1用户id:100的名字:79822a2a-24a1-4c23-861b-8e4ad4692560
```

## 委托同名成员方法

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.subclass(UserManager.class)
	.name("a.b.SubObj")
	.method(named("selectUserName"))
	// 委托给UserManagerInterceptor1中与被拦截方法同签名的静态方法
	// .intercept(MethodDelegation.to(UserManagerInterceptor1.class))
	// 委托给UserManagerInterceptor2中与被拦截方法同签名的成员方法
	.intercept(MethodDelegation.to(new UserManagerInterceptor2()))
	.make();
```

```java
public class UserManagerInterceptor2 {
	// 注意必须为非静态同名方法
    public String selectUserName(Long id) {
        return "UserManagerInterceptor2用户id:"+ id +"的名字:" + UUID.randomUUID().toString();
    }
}
```

## 注解自定义实现

==增强前==

```java
public class UserManager {

    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long id) {
        return "用户id:"+ id +"的名字:" + UUID.randomUUID().toString();
    }
    
    public void print() {
        System.out.println(1);
    }
    
    public int selectAge() {
        return 33;
    }
}

```

==实现==

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.subclass(UserManager.class)
	.name("a.b.SubObj")
	.method(named("selectUserName"))
	// 委托给UserManagerInterceptor1中与被拦截方法同签名的静态方法
	// .intercept(MethodDelegation.to(UserManagerInterceptor1.class))
	// 委托给UserManagerInterceptor2中与被拦截方法同签名的成员方法
	// .intercept(MethodDelegation.to(new UserManagerInterceptor2()))
	// 通过bytebuddy的注解来指定增强方法
	.intercept(MethodDelegation.to(new UserManagerInterceptor3()))
	.make();
```

```java
public class UserManagerInterceptor3 {
    /**
     * 被@RuntimeType标准的方法就是拦截方法
     * 此时方法签名或返回值可以与被拦截方法不一致
     * ByteBuddy会在运行期间给被指定注解修饰的方法参数进行赋值
     */
    @RuntimeType
    public Object aaa(
        // 表示被拦截的目标对象，只有拦截实例方法或构造方法时可用
        @This Object targetObj,
        // 表示被拦截的目标方法，只有拦截实例方法或静态方法时可用
        @Origin Method targetMethod,
        // 目标方法的参数，实例方法或静态方法或构造方法都可用
        @AllArguments Object[] targetMethodArgs,
        // 表示被拦截的目标对象（观察反编译后的结果是目标对象的包装），只有拦截实例方法或构造方法时可用
        @Super Object targetObj2,
        // 若确定父类，也可用具体的父类来接受
        // @Super UserManager targetObj2,
        // 用于调用目标方法(原始的方法)，配合rebase或用subclass的方式增强实例方法时使用
        @SuperCall Callable<?> zuper
    ) {
        // 输出: targetObj = a.b.SubObj@3d6f0054
        System.out.println("targetObj = " + targetObj);
        // 输出: targetMethod.getName() = selectUserName
        System.out.println("targetMethod.getName() = " + targetMethod.getName());
        // 输出: Arrays.toString(targetMethodArgs) = [100]
        System.out.println("Arrays.toString(targetMethodArgs) = " + Arrays.toString(targetMethodArgs));
        // 输出: targetObj2 = a.b.SubObj@3d6f0054
        System.out.println("targetObj2 = " + targetObj2);
        Object call = null;
        try {
            // 调用目标方法
            call = zuper.call();
            // 不能这样写，导致递归调用
            // call = targetMethod.invoke(targetObj, targetMethodArgs);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return call;
    }
}
```

>注意示例中的递归调用的陷阱~

==输出结果==

```
UserManager的构造方法
targetObj = a.b.SubObj@4bb33f74
targetMethod.getName() = selectUserName
Arrays.toString(targetMethodArgs) = [100]
targetObj2 = a.b.SubObj@4bb33f74
result = 用户id:100的名字:d582b92c-a9c3-4172-89a3-aaaec11a8b10
```

==增强后反编译结果==

```java
public class SubObj extends UserManager {
    public String selectUserName(Long var1) {
	    // 自定义拦截器
        UserManagerInterceptor3 var10000 = delegate$gptc0b1;
        // 目标方法
        Method var10002 = cachedValue$uL9b79Nr$ol30kf0;
        // 目标方法参数
        Object[] var10003 = new Object[]{var1};
        // 当前对象的一个包装
        SubObj$auxiliary$WiXdUGru var10004 = new SubObj$auxiliary$WiXdUGru();
        var10004.target = this;
        // 用于调用目标方法(原始的方法) new SubObj$auxiliary$h5iEik5f(this, var1)
        return (String)var10000.aaa(this, var10002, var10003, var10004, new SubObj$auxiliary$h5iEik5f(this, var1));
    }

    public SubObj() {
    }
}
```

字节码指令查看：

![[Pasted image 20231106134016.png|700]]


```java
class SubObj$auxiliary$h5iEik5f implements Runnable, Callable {
    private SubObj argument0;
    private Long argument1;

    public Object call() throws Exception {
	    // selectUserName$accessor$uL9b79Nr指向的增强前的原始方法
        return this.argument0.selectUserName$accessor$uL9b79Nr(this.argument1);
    }

    public void run() {
        this.argument0.selectUserName$accessor$uL9b79Nr(this.argument1);
    }

    SubObj$auxiliary$h5iEik5f(SubObj var1, Long var2) {
        this.argument0 = var1;
        this.argument1 = var2;
    }
}
```

```java
class SubObj$auxiliary$WiXdUGru {
    public volatile SubObj target;

    public boolean equals(Object var1) {
        return this.target.equals$accessor$uL9b79Nr(var1);
    }

    public String toString() {
        return this.target.toString$accessor$uL9b79Nr();
    }

    public int hashCode() {
        return this.target.hashCode$accessor$uL9b79Nr();
    }

    protected Object clone() throws CloneNotSupportedException {
        return this.target.clone$accessor$uL9b79Nr();
    }

    static SubObj$auxiliary$WiXdUGru make() {
        return (SubObj$auxiliary$WiXdUGru)ReflectionFactory.getReflectionFactory().newConstructorForSerialization(SubObj$auxiliary$WiXdUGru.class, Object.class.getDeclaredConstructor()).newInstance();
    }

    public SubObj$auxiliary$WiXdUGru() {
    }
}
```


# 7.动态修改方法的入参

顾名思义，就是在调用方法之前对参数信息就行修改。

==增强前==

```java
public class UserManager {

    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long id) {
        return "用户id:"+ id +"的名字:" + UUID.randomUUID().toString();
    }
    
    public void print() {
        System.out.println(1);
    }
    
    public int selectAge() {
        return 33;
    }
}
```

==实现==

1.自定义MyCallable

```java
public interface MyCallable {
    Object call(Object[] args);
}
```

2.拦截器中使用@Morph代替@SuperCall

```java
public class UserManagerInterceptor4 {

    @RuntimeType
    public Object aaa(
        @AllArguments Object[] targetMethodArgs,
        // 用于调用目标方法
        @Morph MyCallable zuper
    ) {
        Object call = null;
        try {
            if (targetMethodArgs != null && targetMethodArgs.length > 0) {
		        // 修改参数
                targetMethodArgs[0] = Long.parseLong(targetMethodArgs[0].toString()) + 1;
            }
            call = zuper.call(targetMethodArgs);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return call;
    }
}
```

3.指定拦截器前需要先调用withBinders

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.subclass(UserManager.class)
	.name("a.b.SubObj")
	.method(named("selectUserName"))
	.intercept(MethodDelegation
		.withDefaultConfiguration()
		.withBinders(
			// 在UserManagerInterceptor4中使用MyCallable之前需要告诉ByteBuddy
			// 参数的类型是MyCallable
			Morph.Binder.install(MyCallable.class)
		)
		.to(new UserManagerInterceptor4()))
	.make();

DynamicType.Loaded<UserManager> loaded = unloaded.load(getClass().getClassLoader());
Class<? extends UserManager> loadedClass = loaded.getLoaded();
UserManager userManager = loadedClass.newInstance();
String result = userManager.selectUserName(100L);
// result = 用户id:101的名字:0e49d12a-f8de-4a71-b663-347dc3fa31e5
System.out.println("result = " + result);
unloaded.saveIn(new File(path));
```

==输出结果==

```
UserManager的构造方法
result = 用户id:101的名字:ae67cb51-e6dd-4e93-ba61-9cf5a3e99748
```

# 8.对构造方法进行插桩

```java
DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
	.subclass(UserManager.class)
	.name("a.b.SubObj")
	// 拦截任意的构造方法
	.constructor(any()) // 之前使用的都是method，在此使用constructor
	.intercept(
		// 指定在构造方法执行完成之后再委托给拦截器（注意哈~）
		SuperMethodCall.INSTANCE.andThen(
			MethodDelegation.to(new UserManagerInterceptor5())
		)
	)
	.make();

DynamicType.Loaded<UserManager> loaded = unloaded.load(getClass().getClassLoader());
Class<? extends UserManager> loadedClass = loaded.getLoaded();
UserManager userManager = loadedClass.newInstance();
unloaded.saveIn(new File(path));
```

```java
public class UserManagerInterceptor5 {

    @RuntimeType
    public void aaa(@This Object targetObj, @AllArguments Object[] targetMethodArgs) {
        System.out.println(targetObj + "实例化了");
    }
}
```

```
UserManager的构造方法
a.b.SubObj@17a7f733实例化了
```

# 9.对静态方法进行插桩


```java
DynamicType.Unloaded<FileUtils> unloaded = new ByteBuddy()
	.rebase(FileUtils.class)
	// 静态方法拦截不能用redefine，因为redefine不会保留原始方法，在拦截器中就没办法通过zuper来调用
	// .redefine(FileUtils.class)
	// 静态方法是不能被继承的
	// .subclass(FileUtils.class)
	.name("a.b.SubObj")
	.method(named("sizeOf").and(isStatic()))
	.intercept(MethodDelegation.to(new UserManagerInterceptor6()))
	.make();
DynamicType.Loaded<FileUtils> loaded = unloaded.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER);
Class<? extends FileUtils> loadedClass = loaded.getLoaded();
// 获取增强类的sizeOf方法
Method sizeOfMethod = loadedClass.getMethod("sizeOf", File.class);
Object fileSize = sizeOfMethod.invoke(null, new File("D:\\temp\\a\\b\\SubObj.class"));
System.out.println("fileSize = " + fileSize);
unloaded.saveIn(new File(path));
```

```java
public class UserManagerInterceptor6 {

    @RuntimeType
    public Object intercept(
            // @This Object targetObj, 因为是静态方法所以this是获取不到的，但是可以通过@Origin获取到Class
            @Origin Class<?> clazz,
            @Origin Method targetMethod,
            @AllArguments Object[] targetMethodArgs,
            @SuperCall Callable<?> zuper
            ) {
        // 输出: class a.b.SubObj
        System.out.println("clazz = " + clazz);
        // 输出: targetMethod.getName() = sizeOf
        System.out.println("targetMethod.getName() = " + targetMethod.getName());
        // 输出: Arrays.toString(targetMethodArgs) = [D:\tmp\debug.log]
        System.out.println("Arrays.toString(targetMethodArgs) = " + Arrays.toString(targetMethodArgs));
        Object call = null;
        try {
            call = zuper.call();
        }catch (Exception e) {
            e.printStackTrace();
        }
        return call;
    }
}
```

```
clazz = class a.b.SubObj
targetMethod.getName() = sizeOf
Arrays.toString(targetMethodArgs) = [D:\tmp\debug.log]
fileSize = 4227
```

# 10.rebase和redefine默认命名策略


之前生成一个类时，简单说过subclass默认命名策略，rebase和redefine与subclass是不同的。

其实在动态增强的三种方式中已经有所接触。


# 11.ByteBuddy的类加载器

在[[01.ByteBuddy学习笔记#9.对静态方法进行插桩]]部分，在第一次执行时，是正常的，但是在第二次就会抛异常。

![[Pasted image 20231106150622.png|800]]

上述示例代码

```java
DynamicType.Unloaded<FileUtils> unloaded = new ByteBuddy()
	.rebase(FileUtils.class)
	.name("a.b.SubObj")
	.method(named("sizeOf").and(isStatic()))
	.intercept(MethodDelegation.to(new UserManagerInterceptor6()))
	.make();
DynamicType.Loaded<FileUtils> loaded = unloaded.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER); // 
Class<? extends FileUtils> loadedClass = loaded.getLoaded();
// 获取增强类的sizeOf方法
Method sizeOfMethod = loadedClass.getMethod("sizeOf", File.class);
Object fileSize = sizeOfMethod.invoke(null, new File("D:\\temp\\a\\b\\SubObj.class"));
System.out.println("fileSize = " + fileSize);
unloaded.saveIn(new File(path));
```

## 原因分析


记得在[[01.ByteBuddy学习笔记#2.对实例方法插桩]]中，我们打印了类加载器是ByteArrayClassLoader，该类加载器由ByteBuddy实现，因此可以通过打断点去分析具体的报错原因。

断点链路

```
net.bytebuddy.dynamic.DynamicType.Unloaded#load
net.bytebuddy.dynamic.DynamicType.Default.Unloaded#load
net.bytebuddy.dynamic.TypeResolutionStrategy.Passive#initialize
net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default#load
net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default.WrappingDispatcher#load
```

```java
public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, Map<TypeDescription, byte[]> types) {  
    return this.childFirst ? 
	    ChildFirst.load(classLoader, types, this.protectionDomain, this.persistenceHandler, this.packageDefinitionStrategy, this.forbidExisting, this.sealed) :                 // 对应ClassLoadingStrategy.Default.CHILD_FIRST类型 
	    ByteArrayClassLoader.load(classLoader, types, this.protectionDomain, this.persistenceHandler, this.packageDefinitionStrategy, this.forbidExisting, this.sealed);        // 默认实现
}
```


==第一次执行时==

>断点方法：<font color="#f79646">net.bytebuddy.dynamic.loading.ByteArrayClassLoader#load</font>

![[Pasted image 20231106175004.png|900]]

可以看到报错条件是不满足的，所以没有报错~

第一次时，由ByteArrayClassLoader加载~

==第二次执行时==


![[Pasted image 20231106174143.png|1000]]

可以看到报错条件满足了，所以报错~

第二次时，由AppClassLoader加载~

<font color="#4bacc6">这是为什么呢？</font>

* 第一次时，还没有生成SubObj类，当使用ByteArrayClassLoader加载时，根据双亲委派机制，委托给父类的AppClassLoader去加载，它也加载不了，没有嘛，咋加载，所以最终还是自己加载的。
* 第二次时，已经存在之前生成的SubObj类，当使用ByteArrayClassLoader加载时，根据双亲委派机制，委托给父类的AppClassLoader去加载，是可以加载的，因为AppClassLoader的加载目录下已经存在了，最终由AppClassLoader加载了~

>可以把当前用户目录下的a.b.SubObj.class删除，这样AppClassLoader加载不了之后，就只能由ByteArrayClassLoader加载，此时又可以正常加载了~

>此块知识涉及JVM的类加载机制，可参考[[01.基础_类加载机制]]~

可以指定加载器类型，默认加载器类型为ClassLoadingStrategy.Default.WRAPPER。

```java
// 默认ClassLoadingStrategy.Default.WRAPPER
DynamicType.Loaded<FileUtils> loaded = unloaded.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER);
```

当我们指定默认类加载器的时候，再执行一遍，将继续报错。

## 改变策略

为此，ByteBuddy提供了类加载机制策略：

``` java
// ClassLoadingStrategy.Default.CHILD_FIRST打破了双亲委派机制
DynamicType.Loaded<FileUtils> loaded = unloaded.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST);  
Class<? extends FileUtils> loadedClass = loaded.getLoaded();
// net.bytebuddy.dynamic.loading.ByteArrayClassLoader$ChildFirst@290222c1
System.out.println("classLoader = " + loadedClass.getClassLoader());
```

根据上面的断点链路，找到最终实现方法：<font color="#f79646">net.bytebuddy.dynamic.loading.ByteArrayClassLoader.ChildFirst#load</font>

# 12.自定义类的加载路径


```java
@Test  
public void test10() throws Exception {  
    // 从指定jar包加载  
    ClassFileLocator jarFileLocator1 = ClassFileLocator.ForJarFile.of(new File("E:\\programs\\repository\\repo\\org\\springframework\\spring-core\\5.2.15.RELEASE\\spring-core-5.2.15.RELEASE.jar"));  
    // 需要依赖如下包，否则报错：net.bytebuddy.pool.TypePool$Resolution$NoSuchTypeException: Cannot resolve type description for org.springframework.beans.factory.support.AbstractBeanDefinition
    ClassFileLocator jarFileLocator2 = ClassFileLocator.ForJarFile.of(new File("E:\\programs\\repository\\repo\\org\\springframework\\spring-beans\\5.2.15.RELEASE\\spring-beans-5.2.15.RELEASE.jar"));  
    // 从指定目录加载.class  
    ClassFileLocator.ForFolder folderLocator = new ClassFileLocator.ForFolder(new File("E:\\ideaProjects3\\code-tool-prepare\\target\\classes"));  
    // 系统类加载器，如果不加不然会找不到jdk本身的类  
    ClassFileLocator systemLoader = ClassFileLocator.ForClassLoader.ofSystemLoader();  
    ClassFileLocator.Compound compound = new ClassFileLocator.Compound(jarFileLocator1, jarFileLocator2, systemLoader, folderLocator);  
  
    TypePool typePool = TypePool.Default.of(compound);  
  
    // 加载jar中的类，name参数写入全类名获取typeDescription，并不会触发类的加载  
    TypeDescription typeDescription1 = typePool.describe("org.springframework.beans.factory.support.RootBeanDefinition").resolve();  
    DynamicType.Unloaded<Object> unloaded1 = new ByteBuddy()  
        .redefine(typeDescription1, compound)  
        .method(named("getTargetType"))  
        .intercept(FixedValue.nullValue())  
        .make();  
    unloaded1.saveIn(new File(path));  
  
    // 加载文件夹里面的类  
    TypeDescription typeDescription2 = typePool.describe("com.roadjava.codetool.bean.req.GenerateCodeReq").resolve();  
    DynamicType.Unloaded<Object> unloaded2 = new ByteBuddy()  
        .redefine(typeDescription2, compound)  
        .method(named("getDirAbsPath"))  
        .intercept(FixedValue.nullValue())  
        .make();  
    unloaded2.saveIn(new File(path));  
}
```

# 13.清空方法体

清空前

```java
public class UserManager {

    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long id) {
        return "用户id:"+ id +"的名字:" + UUID.randomUUID().toString();
    }

    public void print() {
        System.out.println(1);
    }

    public int selectAge() {
        return 33;
    }
}
```

## v1

```java
@Test
public void test11() throws Exception {
	DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
		.redefine(UserManager.class)
		.method(named("selectUserName").and(
			returns(TypeDescription.CLASS)
				.or(returns(TypeDescription.OBJECT))
				.or(returns(TypeDescription.STRING))
		))
		.intercept(FixedValue.nullValue())
		.method(named("print").and(
			returns(TypeDescription.VOID)
		))
		.intercept(FixedValue.value(TypeDescription.VOID))
		.method(named("selectAge"))
		.intercept(FixedValue.value(0))
		.make();
	unloaded.saveIn(new File(path));
}
```

清空后

```java
public class UserManager {
    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long var1) {
        return null;
    }

    public void print() {
        Class var10000 = Void.TYPE;
    }

    public int selectAge() {
        return 0;
    }
}
```

## v2.1

```java
@Test
public void test11() throws Exception {
	DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
		.redefine(UserManager.class)
		// 会将默认继承父类的方法清空
		.method(any())
		.intercept(StubMethod.INSTANCE)  // 预制拦截器
		.make();
	unloaded.saveIn(new File(path));
}
```

清空后

```java
public class UserManager {
    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long var1) {
        return null;
    }

    public void print() {
    }

    public int selectAge() {
        return 0;
    }

    public boolean equals(Object var1) {
        return false;
    }

    public String toString() {
        return null;
    }

    public int hashCode() {
        return 0;
    }

    protected Object clone() throws CloneNotSupportedException {
        return null;
    }
}
```
## v2.2

```java
@Test
public void test11() throws Exception {
	DynamicType.Unloaded<UserManager> unloaded = new ByteBuddy()
		.redefine(UserManager.class)
		// 会将默认继承父类的方法清空
		// .method(any())
		// 仅清空UserManager声明的方法
		.method(any().and(isDeclaredBy(UserManager.class)))
		.intercept(StubMethod.INSTANCE)  // 预制拦截器 
		.make();
	unloaded.saveIn(new File(path));
}
```

清空后

```java
public class UserManager {
    public UserManager() {
        System.out.println("UserManager的构造方法");
    }

    public String selectUserName(Long var1) {
        return null;
    }

    public void print() {
    }

    public int selectAge() {
        return 0;
    }
}
```

>应用：防止反编译获取源代码~


# 14.ByteBuddy实现JavaAgent_拦截实例方法


# 15.ByteBuddy实现JavaAgent_拦截静态方法



# 16.ByteBuddy实现JavaAgent_拦截构造方法



# 17.ByteBuddy可插拔式插件加载原理


